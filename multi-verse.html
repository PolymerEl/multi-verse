<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="universe-element-debug.html">
<link rel="import" href="../d3-bundle-element/d3-element-multi-debug.html">
<!-- <link rel="import" href="../multi-block/multi-observe-nodes-behavior.html"> -->
<!--
`multi-verse` takes data as input and encapsulate a [`universe`](https://github.com/crossfilter/universe#create-a-new-universe) Object. 
When `universe` changes (query or filtering), `registeredItems` (e.g. charts rendering `universe` data) are notified of the change and will render accordingly.

Sample use:  

  <multi-verse id="universe" data="[[data]]" universe="{{universe}}">
    <multi-group universe="[[universe]]" data="{{data-chart-distance}}" group-by="distances">
      <multi-verse-bar title="distance" data="[[data-chart-distance]]"> </multi-verse-bar>
    </multi-group>
    <multi-group universe="[[universe]]" data="{{data-chart-day}}" group-by="day">
      <multi-verse-pie title="day (pie)" data="[[data-chart-day]]" color-scale="{{colorScale}}" width="{{width}}">
        <multi-legend legend chart-width="[[width]]" scale="[[colorScale]]" position="top-right"></multi-legend>
      </multi-verse-pie>
    </multi-group>
  </multi-verse>

@demo demo/index.html 
-->
<dom-module id="multi-verse">
  <template>
    <content ></content>
  </template>
  <script>
  Polymer({

    is: 'multi-verse',

    properties: {
      /**
       * `data`  the data to pass for creating a new [universe](https://github.com/crossfilter/universe#create-a-new-universe)
       */
      data: {
        type: Array,
        observer: 'observeData'
      },

      /**
       * `universe` expose the created universe
       */
      universe: {
        type: Object,
        notify: true,
        readOnly: true
      },

      /**
       * `registeredItems` Array of web-components that will be notified when `universe` has been queried/filtered
       */
      registeredItems: {
        type: Array,
        value: function() {
          return [];
        }
      },

      /**
       * `groupName` if set will only register webcomponents with the same `groupName`. Otherwise, every web-component that fire a `multi-attached` event will be registered
       */
      groupName: {
        type: String
      }
    },

    listeners: {
      'multi-attached': 'onMultiAttached',
      'multi-detached': 'onMultiDetached',
    },

    behaviors: [
    ],

    /**
     * `observeData` create a new `universe` with the provided data 
     * TODO: add a `multi-column` web-component to define additional universe.generatedColumns and a processing function
     */
    observeData: function(data) {
      
      //TODO : this should be a Function property
      function parseDate(d) {
        return new Date(2001,
          d.substring(0, 2) - 1,
          d.substring(2, 4),
          d.substring(4, 6),
          d.substring(6, 8));
      }
      var formatNumber = d3.format(',d'),
        formatChange = d3.format('+,d'),
        formatDate = d3.timeFormat('%B %d, %Y'),
        formatTime = d3.timeFormat('%I:%M %p');

      var index = 0;  
      data.forEach(function(d, i) {
        d.date = parseDate(d.date);
        d.index = ++index;
      });

      //TODO: GeneratedColumns should be passed as multi-column (still to be defined)
      var me = this;
      var generatedColumns = {
        day: d => d3.timeFormat('%A')(d.date),
        hour: d => Number(d3.timeFormat('%H')(d.date)),
        dayOfWeek: d => d3.timeFormat('%A')(d.date),
        arrivalDelay: d => Math.floor(+d.delay / 30) * 30,
        distances: d => Math.floor(+d.distance / 100) * 100
      };

      function onFilter() {
        me.registeredItems.forEach(function(item) {
          item.render();
        });
      }

      universe(data, {
          generatedColumns: generatedColumns
        }).then(function(uni) {
          me._setUniverse(uni);

          uni.onFilter(onFilter, 100);

          return uni;
        })
        .catch(function(error) {
          console.error(error); // 'oh, no!'
        });

    },

    /**
     * `onMultiAttached` remove the event's `srcElement` to `registeredItems` 
     */
    onMultiDetached: function(e, name) {
      if (!this.groupName || (this.groupName === name)) {
        // e.stopPropagation();
        this.splice('registeredItems', this.registeredItems.indexOf(e.srcElement), 1);
      };
    },

    /**
     * `onMultiAttached` add the event's `srcElement` to `registeredItems` 
     */
    onMultiAttached: function(e, name) {
      if (!this.groupName || (this.groupName === name)) {
        // e.stopPropagation();  
        this.push('registeredItems', e.srcElement);
      }
    },


  });
  </script>
</dom-module>
