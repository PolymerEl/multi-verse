{"version":3,"file":"universe.js","sources":["../../universe/src/lodash.js","../../universe/src/expressions.js","../../universe/src/aggregation.js","../../universe/src/filters.js","../../universe/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/array.js","../../universe/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/filter.js","../../universe/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/identity.js","../../universe/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/null.js","../../universe/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/zero.js","../../universe/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/heap.js","../../universe/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/heapselect.js","../../universe/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/bisect.js","../../universe/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/permute.js","../../universe/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/reduce.js","../../universe/node_modules/.pnpm/registry.npmjs.org/@ranfdev/deepobj/1.0.2/node_modules/@ranfdev/deepobj/dist/deepobj.m.js","../../universe/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/result.js","../../universe/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/index.js","../../universe/src/column.js","../../universe/src/dimension.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/filter.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/count.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/sum.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/avg.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/median.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/min.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/max.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/array.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/filter.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/identity.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/null.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/zero.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/heap.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/heapselect.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/bisect.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/insertionsort.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/permute.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/quicksort.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/reduce.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/result.js","../../universe/node_modules/.pnpm/github.com/preignition/crossfilter/920f95aa8a709d579770641a2c4aae9ce9d53dde/node_modules/crossfilter2/src/index.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/value-count.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/value-list.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/exception-count.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/exception-sum.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/histogram.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/sum-of-squares.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/std.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/nest.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/alias.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/aliasProp.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/data-list.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/custom.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/build.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/accessors.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/parameters.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/cap.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/sortBy.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/reductio.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/postprocessors.js","../../universe/node_modules/.pnpm/github.com/preignition/reductio/7c03a5b71e002532bf74cfa8d1d0767263aa963d/node_modules/reductio/src/postprocess.js","../../universe/src/reductioAggregators.js","../../universe/src/postAggregation.js","../../universe/src/query.js","../../universe/src/reductiofy.js","../../universe/src/clear.js","../../universe/src/destroy.js","../../universe/src/universe.js","../../universe/src/crossfilter.js"],"sourcesContent":["export default {\n  find: find,\n  remove: remove,\n  isArray: isArray,\n  isObject: isObject,\n  isBoolean: isBoolean,\n  isString: isString,\n  isNumber: isNumber,\n  isFunction: isFunction,\n  get: get,\n  set: set,\n  map: map,\n  keys: keys,\n  sortBy: sortBy,\n  forEach: forEach,\n  isUndefined: isUndefined,\n  pick: pick,\n  xor: xor,\n  clone: clone,\n  isEqual: isEqual,\n  replaceArray: replaceArray,\n  uniq: uniq,\n  flatten: flatten,\n  sort: sort,\n  values: values,\n  recurseObject: recurseObject,\n}\n\nfunction find(a, b) {\n  return a.find(b)\n}\n\nfunction remove(a, b) {\n  return a.filter(function (o, i) {\n    var r = b(o)\n    if (r) {\n      a.splice(i, 1)\n      return true\n    }\n    return false\n  })\n}\n\nfunction isArray(a) {\n  return Array.isArray(a)\n}\n\nfunction isObject(d) {\n  return typeof d === 'object' && !isArray(d)\n}\n\nfunction isBoolean(d) {\n  return typeof d === 'boolean'\n}\n\nfunction isString(d) {\n  return typeof d === 'string'\n}\n\nfunction isNumber(d) {\n  return typeof d === 'number'\n}\n\nfunction isFunction(a) {\n  return typeof a === 'function'\n}\n\nfunction get(a, b) {\n  if (isArray(b)) {\n    b = b.join('.')\n  }\n  return b\n    .replace('[', '.').replace(']', '')\n    .split('.')\n    .reduce(\n      function (obj, property) {\n        return obj[property]\n      }, a\n    )\n}\n\nfunction set(obj, prop, value) {\n  if (typeof prop === 'string') {\n    prop = prop\n      .replace('[', '.').replace(']', '')\n      .split('.')\n  }\n  if (prop.length > 1) {\n    var e = prop.shift()\n    Object.assign(obj[e] =\n      Object.prototype.toString.call(obj[e]) === '[object Object]' ? obj[e] : {},\n    prop,\n    value)\n  } else {\n    obj[prop[0]] = value\n  }\n}\n\nfunction map(a, b) {\n  var m\n  var key\n  if (isFunction(b)) {\n    if (isObject(a)) {\n      m = []\n      for (key in a) {\n        if (a.hasOwnProperty(key)) {\n          m.push(b(a[key], key, a))\n        }\n      }\n      return m\n    }\n    return a.map(b)\n  }\n  if (isObject(a)) {\n    m = []\n    for (key in a) {\n      if (a.hasOwnProperty(key)) {\n        m.push(a[key])\n      }\n    }\n    return m\n  }\n  return a.map(function (aa) {\n    return aa[b]\n  })\n}\n\nfunction keys(obj) {\n  return Object.keys(obj)\n}\n\nfunction sortBy(a, b) {\n  if (isFunction(b)) {\n    return a.sort(function (aa, bb) {\n      if (b(aa) > b(bb)) {\n        return 1\n      }\n      if (b(aa) < b(bb)) {\n        return -1\n      }\n      // a must be equal to b\n      return 0\n    })\n  }\n}\n\nfunction forEach(a, b) {\n  if (isObject(a)) {\n    for (var key in a) {\n      if (a.hasOwnProperty(key)) {\n        b(a[key], key, a)\n      }\n    }\n    return\n  }\n  if (isArray(a)) {\n    return a.forEach(b)\n  }\n}\n\nfunction isUndefined(a) {\n  return typeof a === 'undefined'\n}\n\nfunction pick(a, b) {\n  var c = {}\n  forEach(b, function (bb) {\n    if (typeof a[bb] !== 'undefined') {\n      c[bb] = a[bb]\n    }\n  })\n  return c\n}\n\nfunction xor(a, b) {\n  var unique = []\n  forEach(a, function (aa) {\n    if (b.indexOf(aa) === -1) {\n      return unique.push(aa)\n    }\n  })\n  forEach(b, function (bb) {\n    if (a.indexOf(bb) === -1) {\n      return unique.push(bb)\n    }\n  })\n  return unique\n}\n\nfunction clone(a) {\n  return JSON.parse(JSON.stringify(a, function replacer(key, value) {\n    if (typeof value === 'function') {\n      return value.toString()\n    }\n    return value\n  }))\n}\n\nfunction isEqual(x, y) {\n  if ((typeof x === 'object' && x !== null) && (typeof y === 'object' && y !== null)) {\n    if (Object.keys(x).length !== Object.keys(y).length) {\n      return false\n    }\n\n    for (var prop in x) {\n      if (y.hasOwnProperty(prop)) {\n        if (!isEqual(x[prop], y[prop])) {\n          return false\n        }\n      }\n      return false\n    }\n\n    return true\n  } else if (x !== y) {\n    return false\n  }\n  return true\n}\n\nfunction replaceArray(a, b) {\n  var al = a.length\n  var bl = b.length\n  if (al > bl) {\n    a.splice(bl, al - bl)\n  } else if (al < bl) {\n    a.push.apply(a, new Array(bl - al))\n  }\n  forEach(a, function (val, key) {\n    a[key] = b[key]\n  })\n  return a\n}\n\nfunction uniq(a) {\n  var seen = new Set()\n  return a.filter(function (item) {\n    var allow = false\n    if (!seen.has(item)) {\n      seen.add(item)\n      allow = true\n    }\n    return allow\n  })\n}\n\nfunction flatten(aa) {\n  var flattened = []\n  for (var i = 0; i < aa.length; ++i) {\n    var current = aa[i]\n    for (var j = 0; j < current.length; ++j) {\n      flattened.push(current[j])\n    }\n  }\n  return flattened\n}\n\nfunction sort(arr) {\n  for (var i = 1; i < arr.length; i++) {\n    var tmp = arr[i]\n    var j = i\n    while (arr[j - 1] > tmp) {\n      arr[j] = arr[j - 1]\n      --j\n    }\n    arr[j] = tmp\n  }\n\n  return arr\n}\n\nfunction values(a) {\n  var values = []\n  for (var key in a) {\n    if (a.hasOwnProperty(key)) {\n      values.push(a[key])\n    }\n  }\n  return values\n}\n\nfunction recurseObject(obj, cb) {\n  _recurseObject(obj, [])\n  return obj\n  function _recurseObject(obj, path) {\n    for (var k in obj) { //  eslint-disable-line guard-for-in\n      var newPath = clone(path)\n      newPath.push(k)\n      if (typeof obj[k] === 'object' && obj[k] !== null) {\n        _recurseObject(obj[k], newPath)\n      } else {\n        if (!obj.hasOwnProperty(k)) {\n          continue\n        }\n        cb(obj[k], k, newPath)\n      }\n    }\n  }\n}\n","export default {\n  // Getters\n  $field: $field,\n  // Booleans\n  $and: $and,\n  $or: $or,\n  $not: $not,\n\n  // Expressions\n  $eq: $eq,\n  $gt: $gt,\n  $gte: $gte,\n  $lt: $lt,\n  $lte: $lte,\n  $ne: $ne,\n  $type: $type,\n\n  // Array Expressions\n  $in: $in,\n  $nin: $nin,\n  $contains: $contains,\n  $excludes: $excludes,\n  $size: $size,\n}\n\n// Getters\nfunction $field(d, child) {\n  return d[child]\n}\n\n// Operators\n\nfunction $and(d, child) {\n  child = child(d)\n  for (var i = 0; i < child.length; i++) {\n    if (!child[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction $or(d, child) {\n  child = child(d)\n  for (var i = 0; i < child.length; i++) {\n    if (child[i]) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction $not(d, child) {\n  child = child(d)\n  for (var i = 0; i < child.length; i++) {\n    if (child[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n// Expressions\n\nfunction $eq(d, child) {\n  return d === child()\n}\n\nfunction $gt(d, child) {\n  return d > child()\n}\n\nfunction $gte(d, child) {\n  return d >= child()\n}\n\nfunction $lt(d, child) {\n  return d < child()\n}\n\nfunction $lte(d, child) {\n  return d <= child()\n}\n\nfunction $ne(d, child) {\n  return d !== child()\n}\n\nfunction $type(d, child) {\n  return typeof d === child()\n}\n\n// Array Expressions\n\nfunction $in(d, child) {\n  return d.indexOf(child()) > -1\n}\n\nfunction $nin(d, child) {\n  return d.indexOf(child()) === -1\n}\n\nfunction $contains(d, child) {\n  return child().indexOf(d) > -1\n}\n\nfunction $excludes(d, child) {\n  return child().indexOf(d) === -1\n}\n\nfunction $size(d, child) {\n  return d.length === child()\n}\n","import _ from './lodash'\n\nvar aggregators = {\n  // Collections\n  $sum: $sum,\n  $avg: $avg,\n  $max: $max,\n  $min: $min,\n\n  // Pickers\n  $count: $count,\n  $first: $first,\n  $last: $last,\n  $get: $get,\n  $nth: $get, // nth is same as using a get\n  $nthLast: $nthLast,\n  $nthPct: $nthPct,\n  $map: $map,\n}\n\nexport default {\n  makeValueAccessor: makeValueAccessor,\n  aggregators: aggregators,\n  extractKeyValOrArray: extractKeyValOrArray,\n  parseAggregatorParams: parseAggregatorParams,\n}\n\n// This is used to build aggregation stacks for sub-reductio\n// aggregations, or plucking values for use in filters from the data\nfunction makeValueAccessor(obj) {\n  if (typeof obj === 'string') {\n    if (isStringSyntax(obj)) {\n      obj = convertAggregatorString(obj)\n    } else {\n      // Must be a column key. Return an identity accessor\n      return obj\n    }\n  }\n  // Must be a column index. Return an identity accessor\n  if (typeof obj === 'number') {\n    return obj\n  }\n  // If it's an object, we need to build a custom value accessor function\n  if (_.isObject(obj)) {\n    return make()\n  }\n\n  function make() {\n    var stack = makeSubAggregationFunction(obj)\n    return function topStack(d) {\n      return stack(d)\n    }\n  }\n}\n\n// A recursive function that walks the aggregation stack and returns\n// a function. The returned function, when called, will recursively invoke\n// with the properties from the previous stack in reverse order\nfunction makeSubAggregationFunction(obj) {\n  // If its an object, either unwrap all of the properties as an\n  // array of keyValues, or unwrap the first keyValue set as an object\n  obj = _.isObject(obj) ? extractKeyValOrArray(obj) : obj\n\n  // Detect strings\n  if (_.isString(obj)) {\n    // If begins with a $, then we need to convert it over to a regular query object and analyze it again\n    if (isStringSyntax(obj)) {\n      return makeSubAggregationFunction(convertAggregatorString(obj))\n    }\n    // If normal string, then just return a an itentity accessor\n    return function identity(d) {\n      return d[obj]\n    }\n  }\n\n  // If an array, recurse into each item and return as a map\n  if (_.isArray(obj)) {\n    var subStack = _.map(obj, makeSubAggregationFunction)\n    return function getSubStack(d) {\n      return subStack.map(function(s) {\n        return s(d)\n      })\n    }\n  }\n\n  // If object, find the aggregation, and recurse into the value\n  if (obj.key) {\n    if (aggregators[obj.key]) {\n      var subAggregationFunction = makeSubAggregationFunction(obj.value)\n      return function getAggregation(d) {\n        return aggregators[obj.key](subAggregationFunction(d))\n      }\n    }\n    console.error('Could not find aggregration method', obj)\n  }\n\n  return []\n}\n\nfunction extractKeyValOrArray(obj) {\n  var keyVal\n  var values = []\n  for (var key in obj) {\n    if ({}.hasOwnProperty.call(obj, key)) {\n      keyVal = {\n        key: key,\n        value: obj[key],\n      }\n      var subObj = {}\n      subObj[key] = obj[key]\n      values.push(subObj)\n    }\n  }\n  return values.length > 1 ? values : keyVal\n}\n\nfunction isStringSyntax(str) {\n  return ['$', '('].indexOf(str.charAt(0)) > -1\n}\n\nfunction parseAggregatorParams(keyString) {\n  var params = []\n  var p1 = keyString.indexOf('(')\n  var p2 = keyString.indexOf(')')\n  var key = p1 > -1 ? keyString.substring(0, p1) : keyString\n  if (!aggregators[key]) {\n    return false\n  }\n  if (p1 > -1 && p2 > -1 && p2 > p1) {\n    params = keyString.substring(p1 + 1, p2).split(',')\n  }\n\n  return {\n    aggregator: aggregators[key],\n    params: params,\n  }\n}\n\nfunction convertAggregatorString(keyString) {\n  // var obj = {} // obj is defined but not used\n\n  // 1. unwrap top parentheses\n  // 2. detect arrays\n\n  // parentheses\n  var outerParens = /\\((.+)\\)/g\n  // var innerParens = /\\(([^\\(\\)]+)\\)/g  // innerParens is defined but not used\n  // comma not in ()\n  var hasComma = /(?:\\([^\\(\\)]*\\))|(,)/g // eslint-disable-line\n\n  return JSON.parse('{' + unwrapParensAndCommas(keyString) + '}')\n\n  function unwrapParensAndCommas(str) {\n    str = str.replace(' ', '')\n    return (\n      '\"' +\n      str.replace(outerParens, function(p, pr) {\n        if (hasComma.test(pr)) {\n          if (pr.charAt(0) === '$') {\n            return (\n              '\":{\"' +\n              pr.replace(hasComma, function(p2 /* , pr2 */) {\n                if (p2 === ',') {\n                  return ',\"'\n                }\n                return unwrapParensAndCommas(p2).trim()\n              }) +\n              '}'\n            )\n          }\n          return (\n            ':[\"' +\n            pr.replace(\n              hasComma,\n              function(/* p2 , pr2 */) {\n                return '\",\"'\n              }\n            ) +\n            '\"]'\n          )\n        }\n      })\n    )\n  }\n}\n\n// Collection Aggregators\n\nfunction $sum(children) {\n  return children.reduce(function(a, b) {\n    return a + b\n  }, 0)\n}\n\nfunction $avg(children) {\n  return (\n    children.reduce(function(a, b) {\n      return a + b\n    }, 0) / children.length\n  )\n}\n\nfunction $max(children) {\n  return Math.max.apply(null, children)\n}\n\nfunction $min(children) {\n  return Math.min.apply(null, children)\n}\n\nfunction $count(children) {\n  return children.length\n}\n\n/* function $med(children) { // $med is defined but not used\n  children.sort(function(a, b) {\n    return a - b\n  })\n  var half = Math.floor(children.length / 2)\n  if (children.length % 2)\n    return children[half]\n  else\n    return (children[half - 1] + children[half]) / 2.0\n} */\n\nfunction $first(children) {\n  return children[0]\n}\n\nfunction $last(children) {\n  return children[children.length - 1]\n}\n\nfunction $get(children, n) {\n  return children[n]\n}\n\nfunction $nthLast(children, n) {\n  return children[children.length - n]\n}\n\nfunction $nthPct(children, n) {\n  return children[Math.round(children.length * (n / 100))]\n}\n\nfunction $map(children, n) {\n  return children.map(function(d) {\n    return d[n]\n  })\n}\n","import _ from './lodash'\nimport expressions from './expressions'\nimport aggregation from './aggregation'\n\nexport default function (service) {\n  return {\n    filter: filter,\n    filterAll: filterAll,\n    applyFilters: applyFilters,\n    makeFunction: makeFunction,\n    scanForDynamicFilters: scanForDynamicFilters,\n  }\n\n  function filter(column, fil, isRange, replace) {\n    return getColumn(column)\n      .then(function (column) {\n      // Clone a copy of the new filters\n        var newFilters = Object.assign({}, service.filters)\n        // Here we use the registered column key despite the filter key passed, just in case the filter key's ordering is ordered differently :)\n        var filterKey = column.key\n        if (column.complex === 'array') {\n          filterKey = JSON.stringify(column.key)\n        }\n        if (column.complex === 'function') {\n          filterKey = column.key.toString()\n        }\n        // Build the filter object\n        newFilters[filterKey] = buildFilterObject(fil, isRange, replace)\n\n        return applyFilters(newFilters)\n      })\n  }\n\n  function getColumn(column) {\n    var exists = service.column.find(column)\n    // If the filters dimension doesn't exist yet, try and create it\n    return new Promise(function (resolve, reject) {\n      try {\n        if (!exists) {\n          return resolve(service.column({\n            key: column,\n            temporary: true,\n          })\n            .then(function () {\n              // It was able to be created, so retrieve and return it\n              return service.column.find(column)\n            })\n          )\n        } else {\n          // It exists, so just return what we found\n          resolve(exists)\n        }\n      } catch (err) {\n        reject(err)\n      }\n    })\n  }\n\n  function filterAll(fils) {\n    // If empty, remove all filters\n    if (!fils) {\n      service.columns.forEach(function (col) {\n        col.dimension.filterAll()\n      })\n      return applyFilters({})\n    }\n\n    // Clone a copy for the new filters\n    var newFilters = Object.assign({}, service.filters)\n\n    var ds = _.map(fils, function (fil) {\n      return getColumn(fil.column)\n        .then(function (column) {\n          // Here we use the registered column key despite the filter key passed, just in case the filter key's ordering is ordered differently :)\n          var filterKey = column.complex ? JSON.stringify(column.key) : column.key\n          // Build the filter object\n          newFilters[filterKey] = buildFilterObject(fil.value, fil.isRange, fil.replace)\n        })\n    })\n\n    return Promise.all(ds)\n      .then(function () {\n        return applyFilters(newFilters)\n      })\n  }\n\n  function buildFilterObject(fil, isRange, replace) {\n    if (_.isUndefined(fil)) {\n      return false\n    }\n    if (_.isFunction(fil)) {\n      return {\n        value: fil,\n        function: fil,\n        replace: true,\n        type: 'function',\n      }\n    }\n    if (_.isObject(fil)) {\n      return {\n        value: fil,\n        function: makeFunction(fil),\n        replace: true,\n        type: 'function',\n      }\n    }\n    if (_.isArray(fil)) {\n      return {\n        value: fil,\n        replace: isRange || replace,\n        type: isRange ? 'range' : 'inclusive',\n      }\n    }\n    return {\n      value: fil,\n      replace: replace,\n      type: 'exact',\n    }\n  }\n\n  function applyFilters(newFilters) {\n    var ds = _.map(newFilters, function (fil, i) {\n      var existing = service.filters[i]\n      // Filters are the same, so no change is needed on this column\n      if (fil === existing) {\n        return Promise.resolve()\n      }\n      var column\n      // Retrieve complex columns by decoding the column key as json\n      if (i.charAt(0) === '[') {\n        column = service.column.find(JSON.parse(i))\n      } else {\n        // Retrieve the column normally\n        column = service.column.find(i)\n      }\n\n      // Toggling a filter value is a bit different from replacing them\n      if (fil && existing && !fil.replace) {\n        newFilters[i] = fil = toggleFilters(fil, existing)\n      }\n\n      // If no filter, remove everything from the dimension\n      if (!fil) {\n        return Promise.resolve(column.dimension.filterAll())\n      }\n      if (fil.type === 'exact') {\n        return Promise.resolve(column.dimension.filterExact(fil.value))\n      }\n      if (fil.type === 'range') {\n        return Promise.resolve(column.dimension.filterRange(fil.value))\n      }\n      if (fil.type === 'inclusive') {\n        return Promise.resolve(column.dimension.filterFunction(function (d) {\n          return fil.value.indexOf(d) > -1\n        }))\n      }\n      if (fil.type === 'function') {\n        return Promise.resolve(column.dimension.filterFunction(fil.function))\n      }\n      // By default if something craps up, just remove all filters\n      return Promise.resolve(column.dimension.filterAll())\n    })\n\n    return Promise.all(ds)\n      .then(function () {\n        // Save the new filters satate\n        service.filters = newFilters\n\n        // Pluck and remove falsey filters from the mix\n        var tryRemoval = []\n        _.forEach(service.filters, function (val, key) {\n          if (!val) {\n            tryRemoval.push({\n              key: key,\n              val: val,\n            })\n            delete service.filters[key]\n          }\n        })\n\n        // If any of those filters are the last dependency for the column, then remove the column\n        return Promise.all(_.map(tryRemoval, function (v) {\n          var column = service.column.find((v.key.charAt(0) === '[') ? JSON.parse(v.key) : v.key)\n          if (column.temporary && !column.dynamicReference) {\n            return service.clear(column.key)\n          }\n        }))\n      })\n      .then(function () {\n        // Call the filterListeners and wait for their return\n        return Promise.all(_.map(service.filterListeners, function (listener) {\n          return listener()\n        }))\n      })\n      .then(function () {\n        return service\n      })\n  }\n\n  function toggleFilters(fil, existing) {\n    // Exact from Inclusive\n    if (fil.type === 'exact' && existing.type === 'inclusive') {\n      fil.value = _.xor([fil.value], existing.value)\n    } else if (fil.type === 'inclusive' && existing.type === 'exact') { // Inclusive from Exact\n      fil.value = _.xor(fil.value, [existing.value])\n    } else if (fil.type === 'inclusive' && existing.type === 'inclusive') { // Inclusive / Inclusive Merge\n      fil.value = _.xor(fil.value, existing.value)\n    } else if (fil.type === 'exact' && existing.type === 'exact') { // Exact / Exact\n      // If the values are the same, remove the filter entirely\n      if (fil.value === existing.value) {\n        return false\n      }\n      // They they are different, make an array\n      fil.value = [fil.value, existing.value]\n    }\n\n    // Set the new type based on the merged values\n    if (!fil.value.length) {\n      fil = false\n    } else if (fil.value.length === 1) {\n      fil.type = 'exact'\n      fil.value = fil.value[0]\n    } else {\n      fil.type = 'inclusive'\n    }\n\n    return fil\n  }\n\n  function scanForDynamicFilters(query) {\n    // Here we check to see if there are any relative references to the raw data\n    // being used in the filter. If so, we need to build those dimensions and keep\n    // them updated so the filters can be rebuilt if needed\n    // The supported keys right now are: $column, $data\n    var columns = []\n    walk(query.filter)\n    return columns\n\n    function walk(obj) {\n      _.forEach(obj, function (val, key) {\n        // find the data references, if any\n        var ref = findDataReferences(val, key)\n        if (ref) {\n          columns.push(ref)\n        }\n        // if it's a string\n        if (_.isString(val)) {\n          ref = findDataReferences(null, val)\n          if (ref) {\n            columns.push(ref)\n          }\n        }\n        // If it's another object, keep looking\n        if (_.isObject(val)) {\n          walk(val)\n        }\n      })\n    }\n  }\n\n  function findDataReferences(val, key) {\n    // look for the $data string as a value\n    if (key === '$data') {\n      return true\n    }\n\n    // look for the $column key and it's value as a string\n    if (key && key === '$column') {\n      if (_.isString(val)) {\n        return val\n      }\n      console.warn('The value for filter \"$column\" must be a valid column key', val)\n      return false\n    }\n  }\n\n  function makeFunction(obj, isAggregation) {\n    var subGetters\n\n    // Detect raw $data reference\n    if (_.isString(obj)) {\n      var dataRef = findDataReferences(null, obj)\n      if (dataRef) {\n        var data = service.cf.all()\n        return function () {\n          return data\n        }\n      }\n    }\n\n    if (_.isString(obj) || _.isNumber(obj) || _.isBoolean(obj)) {\n      return function (d) {\n        if (typeof d === 'undefined') {\n          return obj\n        }\n        return expressions.$eq(d, function () {\n          return obj\n        })\n      }\n    }\n\n    // If an array, recurse into each item and return as a map\n    if (_.isArray(obj)) {\n      subGetters = _.map(obj, function (o) {\n        return makeFunction(o, isAggregation)\n      })\n      return function (d) {\n        return subGetters.map(function (s) {\n          return s(d)\n        })\n      }\n    }\n\n    // If object, return a recursion function that itself, returns the results of all of the object keys\n    if (_.isObject(obj)) {\n      subGetters = _.map(obj, function (val, key) {\n        // Get the child\n        var getSub = makeFunction(val, isAggregation)\n\n        // Detect raw $column references\n        var dataRef = findDataReferences(val, key)\n        if (dataRef) {\n          var column = service.column.find(dataRef)\n          var data = column.values\n          return function () {\n            return data\n          }\n        }\n\n        // If expression, pass the parentValue and the subGetter\n        if (expressions[key]) {\n          return function (d) {\n            return expressions[key](d, getSub)\n          }\n        }\n\n        var aggregatorObj = aggregation.parseAggregatorParams(key)\n        if (aggregatorObj) {\n          // Make sure that any further operations are for aggregations\n          // and not filters\n          isAggregation = true\n          // here we pass true to makeFunction which denotes that\n          // an aggregatino chain has started and to stop using $AND\n          getSub = makeFunction(val, isAggregation)\n          // If it's an aggregation object, be sure to pass in the children, and then any additional params passed into the aggregation string\n          return function () {\n            return aggregatorObj.aggregator.apply(null, [getSub()].concat(aggregatorObj.params))\n          }\n        }\n\n        // It must be a string then. Pluck that string key from parent, and pass it as the new value to the subGetter\n        return function (d) {\n          d = d[key]\n          return getSub(d, getSub)\n        }\n      })\n\n      // All object expressions are basically AND's\n      // Return AND with a map of the subGetters\n      if (isAggregation) {\n        if (subGetters.length === 1) {\n          return function (d) {\n            return subGetters[0](d)\n          }\n        }\n        return function (d) {\n          return _.map(subGetters, function (getSub) {\n            return getSub(d)\n          })\n        }\n      }\n      return function (d) {\n        return expressions.$and(d, function (d) {\n          return _.map(subGetters, function (getSub) {\n            return getSub(d)\n          })\n        })\n      }\n    }\n\n    console.log('no expression found for ', obj)\n    return false\n  }\n}\n","let array8 = arrayUntyped,\n    array16 = arrayUntyped,\n    array32 = arrayUntyped,\n    arrayLengthen = arrayLengthenUntyped,\n    arrayWiden = arrayWidenUntyped;\nif (typeof Uint8Array !== \"undefined\") {\n  array8 = function(n) { return new Uint8Array(n); };\n  array16 = function(n) { return new Uint16Array(n); };\n  array32 = function(n) { return new Uint32Array(n); };\n\n  arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = array16(array.length); break;\n      case 32: copy = array32(array.length); break;\n      default: throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\n\n// An arbitrarily-wide array of bitmasks\nfunction bitarray(n) {\n  this.length = n;\n  this.subarrays = 1;\n  this.width = 8;\n  this.masks = {\n    0: 0\n  }\n\n  this[0] = array8(n);\n}\n\nbitarray.prototype.lengthen = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i] = arrayLengthen(this[i], n);\n  }\n  this.length = n;\n};\n\n// Reserve a new bit index in the array, returns {offset, one}\nbitarray.prototype.add = function() {\n  var m, w, one, i, len;\n\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    m = this.masks[i];\n    w = this.width - (32 * i);\n    // isolate the rightmost zero bit and return it as an unsigned int of 32 bits, if NaN or -1, return a 0 \n    one = (~m & (m + 1)) >>> 0;\n\n    if (w >= 32 && !one) {\n      continue;\n    }\n\n    if (w < 32 && (one & (1 << w))) {\n      // widen this subarray\n      this[i] = arrayWiden(this[i], w <<= 1);\n      this.width = 32 * i + w;\n    }\n\n    this.masks[i] |= one;\n\n    return {\n      offset: i,\n      one: one\n    };\n  }\n\n  // add a new subarray\n  this[this.subarrays] = array8(this.length);\n  this.masks[this.subarrays] = 1;\n  this.width += 8;\n  return {\n    offset: this.subarrays++,\n    one: 1\n  };\n};\n\n// Copy record from index src to index dest\nbitarray.prototype.copy = function(dest, src) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i][dest] = this[i][src];\n  }\n};\n\n// Truncate the array to the given length\nbitarray.prototype.truncate = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    for (var j = this.length - 1; j >= n; j--) {\n      this[i][j] = 0;\n    }\n  }\n  this.length = n;\n};\n\n// Checks that all bits for the given index are 0\nbitarray.prototype.zero = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for possibly one\nbitarray.prototype.zeroExcept = function(n, offset, zero) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (i === offset ? this[i][n] & zero : this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for the specified mask.\n// The mask should be an array of the same size as the filter subarrays width.\nbitarray.prototype.zeroExceptMask = function(n, mask) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] & mask[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks that only the specified bit is set for the given index\nbitarray.prototype.only = function(n, offset, one) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] != (i === offset ? one : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that only the specified bit is set for the given index except for possibly one other\nbitarray.prototype.onlyExcept = function(n, offset, zero, onlyOffset, onlyOne) {\n  var mask;\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    mask = this[i][n];\n    if (i === offset)\n      mask &= zero;\n    if (mask != (i === onlyOffset ? onlyOne : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport default {\n  array8: arrayUntyped,\n  array16: arrayUntyped,\n  array32: arrayUntyped,\n  arrayLengthen: arrayLengthenUntyped,\n  arrayWiden: arrayWidenUntyped,\n  bitarray: bitarray\n};\n","const filterExact = (bisect, value) => {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nconst filterRange = (bisect, range) => {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nconst filterAll = values => {\n  return [0, values.length];\n}\n\nexport default {\n  filterExact,\n  filterRange,\n  filterAll\n};\n","export default d => {\n  return d;\n};\n","export default () =>  {\n  return null;\n}\n","export default () => {\n  return 0;\n}\n","import identity from './identity';\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\n\nconst h = heap_by(identity);\nh.by = heap_by;\n\nexport default h;\n","import identity from './identity';\nimport xFilterHeap from './heap';\n\nfunction heapselect_by(f) {\n  var heap = xFilterHeap.by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\n\n\nconst h = heapselect_by(identity);\nh.by = heapselect_by; // assign the raw function to the export as well\n\nexport default h;\n","import identity from './identity';\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\n\nconst bisect = bisect_by(identity);\nbisect.by = bisect_by; // assign the raw function to the export as well\n\nexport default bisect;\n\n","export default (array, index, deep) => {\n  for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\n","const reduceIncrement = p => {\n  return p + 1;\n}\n\nconst reduceDecrement = p => {\n  return p - 1;\n}\n\nconst reduceAdd = f => {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nconst reduceSubtract = f => {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\n\nexport default {\n  reduceIncrement,\n  reduceDecrement,\n  reduceAdd,\n  reduceSubtract\n};\n","export default function(t,e,i,n,r){for(r in n=(i=i.split(\".\")).splice(-1,1),i)e=e[i[r]]=e[i[r]]||{};return t(e,n)};\n//# sourceMappingURL=deepobj.m.js.map\n","import deep from \"@ranfdev/deepobj\"\n// Note(cg): result was previsouly using lodash.result, not ESM compatible.\n \nconst get = (obj, prop) => {\n  const value = obj[prop];\n  return (typeof value === 'function') ? value.call(obj) : value;\n}\n\n/**\n * get value of object at a deep path.\n * if the resolved value is a function,\n * it's invoked with the `this` binding of \n * its parent object and its result is returned. \n *  \n * @param  {Object} obj  the object (e.g. { 'a': [{ 'b': { 'c1': 3, 'c2': 4} }], 'd': {e:1} }; )\n * @param  {String} path deep path (e.g. `d.e`` or `a[0].b.c1`. Dot notation (a.0.b)is also supported)\n * @return {Any}      the resolved value\n */\nconst reg = /\\[([\\w\\d]+)\\]/g;\nexport default (obj, path) => {\n  return deep(get, obj, path.replace(reg, '.$1'))\n}\n","import xfilterArray from './array';\nimport xfilterFilter from './filter';\nimport cr_identity from './identity';\nimport cr_null from './null';\nimport cr_zero from './zero';\nimport xfilterHeapselect from './heapselect';\nimport xfilterHeap from './heap';\nimport bisect from './bisect';\nimport permute from './permute';\nimport xfilterReduce from './reduce';\nimport result from './result';\n\n// constants\nvar REMOVED_INDEX = -1;\n\ncrossfilter.heap = xfilterHeap;\ncrossfilter.heapselect = xfilterHeapselect;\ncrossfilter.bisect = bisect;\ncrossfilter.permute = permute;\nexport default crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size,\n    all: all,\n    allFiltered: allFiltered,\n    onChange: onChange,\n    isElementFiltered: isElementFiltered\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      filters, // 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = [], // when data is removed\n      callbacks = [];\n\n  filters = new xfilterArray.bitarray(0);\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add…\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters.lengthen(n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n      triggerOnChange('dataAdded');\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters, or if a predicate function is passed,\n  // removes all records matching the predicate (ignoring filters).\n  function removeData(predicate) {\n    var // Mapping from old record indexes to new indexes (after records removed)\n        newIndex = new Array(n),\n        removed = [],\n        usePred = typeof predicate === 'function',\n        shouldRemove = function (i) {\n          return usePred ? predicate(data[i], i) : filters.zero(i)\n        };\n\n    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n      if ( shouldRemove(index1) ) {\n        removed.push(index1);\n        newIndex[index1] = REMOVED_INDEX;\n      } else {\n        newIndex[index1] = index2++;\n      }\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(-1, -1, [], removed, true); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n      if ( newIndex[index3] !== REMOVED_INDEX ) {\n        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n        ++index4;\n      }\n    }\n\n    data.length = n = index4;\n    filters.truncate(index4);\n    triggerOnChange('dataRemoved');\n  }\n\n  function maskForDimensions(dimensions) {\n    var n,\n        d,\n        len,\n        id,\n        mask = Array(filters.subarrays);\n    for (n = 0; n < filters.subarrays; n++) { mask[n] = ~0; }\n    for (d = 0, len = dimensions.length; d < len; d++) {\n      // The top bits of the ID are the subarray offset and the lower bits are the bit\n      // offset of the \"one\" mask.\n      id = dimensions[d].id();\n      mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n    }\n    return mask;\n  }\n\n  // Return true if the data element at index i is filtered IN.\n  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n  function isElementFiltered(i, ignore_dimensions) {\n    var mask = maskForDimensions(ignore_dimensions || []);\n    return filters.zeroExceptMask(i,mask);\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value, iterable) {\n\n    if (typeof value === 'string') {\n      var accessorPath = value;\n      value = function(d) { return result(d, accessorPath); };\n    }\n\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      currentFilter: currentFilter,\n      hasCurrentFilter: hasCurrentFilter,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose, // for backwards-compatibility\n      accessor: value,\n      id: function() { return id; }\n    };\n\n    var one, // lowest unset bit as mask, e.g., 00001000\n        zero, // inverted one, e.g., 11110111\n        offset, // offset into the filters arrays\n        id, // unique ID for this dimension (reused when dimensions are disposed)\n        values, // sorted, cached array\n        index, // maps sorted value index -> record index (in data)\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        iterablesIndexCount,\n        iterablesIndexFilterStatus,\n        iterablesEmptyRows = [],\n        sortRange = function(n) {\n          return cr_range(n).sort(function(A, B) {\n            var a = newValues[A], b = newValues[B];\n            return a < b ? -1 : a > b ? 1 : A - B;\n          });\n        },\n        refilter = xfilterFilter.filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        filterValue, // the value used for filtering (value, array, function or undefined)\n        filterValuePresent, // true if filterValue contains something\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0,\n        t = 0,\n        k;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Add a new dimension in the filter bitmap and store the offset and bitmask.\n    var tmp = filters.add();\n    offset = tmp.offset;\n    one = tmp.one;\n    zero = ~one;\n\n    // Create a unique ID for the dimension\n    // IDs will be re-used if dimensions are disposed.\n    // For internal use the ID is the subarray offset shifted left 7 bits or'd with the\n    // bit offset of the set bit in the dimension's \"one\" mask.\n    id = (offset << 7) | (Math.log(one) / Math.log(2));\n\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n      var newIterablesIndexCount,\n          newIterablesIndexFilterStatus;\n\n      if (iterable){\n        // Count all the values\n        t = 0;\n        j = 0;\n        k = [];\n\n        for (var i0 = 0; i0 < newData.length; i0++) {\n          for(j = 0, k = value(newData[i0]); j < k.length; j++) {\n            t++;\n          }\n        }\n\n        newValues = [];\n        newIterablesIndexCount = cr_range(newData.length);\n        newIterablesIndexFilterStatus = cr_index(t,1);\n        var unsortedIndex = cr_range(t);\n\n        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n          k = value(newData[index1])\n          //\n          if(!k.length){\n            newIterablesIndexCount[index1] = 0;\n            iterablesEmptyRows.push(index1 + n0);\n            continue;\n          }\n          newIterablesIndexCount[index1] = k.length\n          for (j = 0; j < k.length; j++) {\n            newValues.push(k[j]);\n            unsortedIndex[l] = index1;\n            l++;\n          }\n        }\n\n        // Create the Sort map used to sort both the values and the valueToData indices\n        var sortMap = sortRange(t);\n\n        // Use the sortMap to sort the newValues\n        newValues = permute(newValues, sortMap);\n\n\n        // Use the sortMap to sort the unsortedIndex map\n        // newIndex should be a map of sortedValue -> crossfilterData\n        newIndex = permute(unsortedIndex, sortMap)\n\n      } else{\n        // Permute new values into natural order using a standard sorted index.\n        newValues = newData.map(value);\n        newIndex = sortRange(n1);\n        newValues = permute(newValues, newIndex);\n      }\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];\n\n      var index2, index3, index4;\n      if(iterable) {\n        n1 = t;\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              if(--newIterablesIndexCount[newIndex[index2]] === 0) {\n                filters[offset][newIndex[index2] + n0] |= one;\n              }\n              newIterablesIndexFilterStatus[index2] = 1;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            if(--newIterablesIndexCount[newIndex[index3]] === 0) {\n              filters[offset][newIndex[index3] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index3] = 1;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            if(--newIterablesIndexCount[newIndex[index4]] === 0) {\n              filters[offset][newIndex[index4] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index4] = 1;\n          }\n        }\n      } else {\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              filters[offset][newIndex[index2] + n0] |= one;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            filters[offset][newIndex[index3] + n0] |= one;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            filters[offset][newIndex[index4] + n0] |= one;\n          }\n        }\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        iterablesIndexCount = newIterablesIndexCount;\n        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n\n\n      var oldValues = values,\n        oldIndex = index,\n        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n        old_n0,\n        i1 = 0;\n\n      i0 = 0;\n\n      if(iterable){\n        old_n0 = n0\n        n0 = oldValues.length;\n        n1 = t\n      }\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = iterable ? new Array(n0 + n1) : new Array(n);\n      index = iterable ? new Array(n0 + n1) : cr_index(n, n);\n      if(iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);\n\n      // Concatenate the newIterablesIndexCount onto the old one.\n      if(iterable) {\n        var oldiiclength = iterablesIndexCount.length;\n        iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n        for(var j=0; j+oldiiclength < n; j++) {\n          iterablesIndexCount[j+oldiiclength] = newIterablesIndexCount[j];\n        }\n      }\n\n      // Merge the old and new sorted values, and old and new index.\n      var index5 = 0;\n      for (; i0 < n0 && i1 < n1; ++index5) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[index5] = oldValues[i0];\n          if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0++];\n        } else {\n          values[index5] = newValues[i1];\n          if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++index5) {\n        values[index5] = oldValues[i0];\n        if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n        index[index5] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++index5) {\n        values[index5] = newValues[i1];\n        if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      if (iterable) {\n        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n            i1++;\n          }\n        }\n        iterablesEmptyRows.length = i1;\n        for (i0 = 0, i1 = 0; i0 < n; i0++) {\n          if (reIndex[i0] !== REMOVED_INDEX) {\n            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n            i1++;\n          }\n        }\n        iterablesIndexCount = iterablesIndexCount.slice(0, i1);\n      }\n      // Rewrite our index, overwriting removed values\n      var n0 = values.length;\n      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n        oldDataIndex = index[i];\n        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[oldDataIndex];\n          if (iterable) {\n            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n          }\n          ++j;\n        }\n      }\n      values.length = j;\n      if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);\n      while (j < n0) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; }, bounds[0] === 0 && bounds[1] === values.length);\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [];\n\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      if(!iterable) {\n        // Flip filters normally.\n\n        for(i=0; i<added.length; i++) {\n          filters[offset][added[i]] ^= one;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          filters[offset][removed[i]] ^= one;\n        }\n\n      } else {\n        // For iterables, we need to figure out if the row has been completely removed vs partially included\n        // Only count a row as added if it is not already being aggregated. Only count a row\n        // as removed if the last element being aggregated is removed.\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          iterablesIndexCount[added[i]]++\n          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n          if(iterablesIndexCount[added[i]] === 1) {\n            filters[offset][added[i]] ^= one;\n            newAdded.push(added[i]);\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          iterablesIndexCount[removed[i]]--\n          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n          if(iterablesIndexCount[removed[i]] === 0) {\n            filters[offset][removed[i]] ^= one;\n            newRemoved.push(removed[i]);\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(refilter === xfilterFilter.filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      filterValue = value;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      filterValue = range;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      filterValue = undefined;\n      filterValuePresent = false;\n      return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      filterValue = f;\n      filterValuePresent = true;\n      \n      refilterFunction = f;\n      refilter = xfilterFilter.filterAll;\n\n      filterIndexFunction(f, false);\n\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f, filterAll) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [],\n          indexLength = values.length;\n\n      if(!iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) added.push(k);\n            else removed.push(k);\n          }\n        }\n      }\n\n      if(iterable) {\n        for(i=0; i < indexLength; ++i) {\n          if(f(values[i], i)) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          } else {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n      }\n\n      if(!iterable) {\n        for(i=0; i<added.length; i++) {\n          if(filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          if(!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n        }\n      } else {\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          // First check this particular value needs to be added\n          if(iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n            iterablesIndexCount[added[i]]++\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n            if(iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          // First check this particular value needs to be removed\n          if(iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n            iterablesIndexCount[removed[i]]--\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n            if(iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n    }\n    \n    function currentFilter() {\n      return filterValue;\n    }\n    \n    function hasCurrentFilter() {\n      return filterValuePresent;\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k, top_offset) {\n      var array = [],\n          i = hi0,\n          j,\n          toSkip = 0;\n\n      if(top_offset && top_offset > 0) toSkip = top_offset;\n\n      while (--i >= lo0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n      }\n\n      if(iterable){\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          // Add row with empty iterable column at the end\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k, bottom_offset) {\n      var array = [],\n          i,\n          j,\n          toSkip = 0;\n\n      if(bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n\n      if(iterable) {\n        // Add row with empty iterable column at the top\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      i = lo0;\n\n      while (i < hi0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id ↦ group id\n          groupWidth = 8,\n          groupCapacity = capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = cr_null,\n          reset = cr_null,\n          resetNeeded = true,\n          groupAll = key === cr_null,\n          n0old;\n\n      if (arguments.length < 1) key = cr_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n\n        if(iterable) {\n          n0old = n0\n          n0 = values.length - newValues.length\n          n1 = newValues.length;\n        }\n\n        var oldGroups = groups,\n            reIndex = iterable ? [] : cr_index(k, groupCapacity),\n            add = reduceAdd,\n            remove = reduceRemove,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = cr_null;\n        if (resetNeeded) remove = initial = cr_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        if(iterable){\n          groupIndex = k0 ? groupIndex : [];\n        }\n        else{\n          groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);\n        }\n\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain…\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            g0 = oldGroups[++i0];\n            if (g0) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n\n          while (x1 <= x) {\n            j = newIndex[i1] + (iterable ? n0old : n0)\n\n\n            if(iterable){\n              if(groupIndex[j]){\n                groupIndex[j].push(k)\n              }\n              else{\n                groupIndex[j] = [k]\n              }\n            }\n            else{\n              groupIndex[j] = k;\n            }\n\n            // Always add new values to groups. Only remove when not in filter.\n            // This gives groups full information on data life-cycle.\n            g.value = add(g.value, data[j], true);\n            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater th1an all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n\n        // Fill in gaps with empty arrays where there may have been rows with empty iterables\n        if(iterable){\n          for (var index1 = 0; index1 < n; index1++) {\n            if(!groupIndex[index1]){\n              groupIndex[index1] = [];\n            }\n          }\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if(k > i0){\n          if(iterable){\n            for (i0 = 0; i0 < n0old; ++i0) {\n              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n              }\n            }\n          }\n          else{\n            for (i0 = 0; i0 < n0; ++i0) {\n              groupIndex[i0] = reIndex[groupIndex[i0]];\n            }\n          }\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1 || iterable) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = cr_null;\n            reset = cr_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if(iterable){\n            k++\n            return\n          }\n          if (++k === groupCapacity) {\n            reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n            groupCapacity = capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData(reIndex) {\n        if (k > 1 || iterable) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = cr_index(oldK, oldK),\n              i,\n              i0,\n              j;\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          if (!iterable) {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            }\n          } else {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                groupIndex[j] = groupIndex[i];\n                for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                  seenGroups[groupIndex[j][i0]] = 1;\n                }\n                ++j;\n              }\n            }\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1 || iterable) {\n            // Reindex the group index using seenGroups to find the new index.\n            if (!iterable) {\n              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n            } else {\n              for (i = 0; i < j; ++i) {\n                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                }\n              }\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = cr_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = cr_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            j,\n            k,\n            n,\n            g;\n\n        if(iterable){\n          // Add the added values.\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceAdd(g.value, data[k], false, j);\n              }\n            }\n          }\n\n          // Remove the removed values.\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceRemove(g.value, data[k], notFilter, j);\n              }\n            }\n          }\n          return;\n        }\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            j,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        if(iterable){\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < groupIndex[i].length; j++) {\n              g = groups[groupIndex[i][j]];\n              g.value = reduceAdd(g.value, data[i], true, j);\n            }\n          }\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceRemove(g.value, data[i], false, j);\n              }\n            }\n          }\n          return;\n        }\n\n        for (i = 0; i < n; ++i) {\n          g = groups[groupIndex[i]];\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        for (i = 0; i < n; ++i) {\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = xfilterHeapselect.by(valueOf);\n        heap = xfilterHeap.by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(cr_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        i = dimensionGroups.indexOf(group);\n        if (i >= 0) dimensionGroups.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(cr_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      filters.masks[offset] &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Cycle through all the values.\n      for (i = n0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, filterOffset, added, removed, notFilter) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (filters.zero(k = added[i])) {\n          reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters.only(k = removed[i], filterOffset, filterOne)) {\n          reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      // Cycle through all the values.\n      for (i = 0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if it is filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i, 1);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i, 1);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  // Returns the raw row data contained in this crossfilter\n  function all(){\n    return data;\n  }\n\n  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n  function allFiltered(ignore_dimensions) {\n    var array = [],\n        i = 0,\n        mask = maskForDimensions(ignore_dimensions || []);\n\n      for (i = 0; i < n; i++) {\n        if (filters.zeroExceptMask(i, mask)) {\n          array.push(data[i]);\n        }\n      }\n\n      return array;\n  }\n\n  function onChange(cb){\n    if(typeof cb !== 'function'){\n      /* eslint no-console: 0 */\n      console.warn('onChange callback parameter must be a function!');\n      return;\n    }\n    callbacks.push(cb);\n    return function(){\n      callbacks.splice(callbacks.indexOf(cb), 1);\n    };\n  }\n\n  function triggerOnChange(eventName){\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](eventName);\n    }\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction cr_index(n, m) {\n  return (m < 0x101\n      ? xfilterArray.array8 : m < 0x10001\n      ? xfilterArray.array16\n      : xfilterArray.array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction cr_range(n) {\n  var range = cr_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n","import _ from './lodash'\nimport _dimension from './dimension'\n\nexport default function (service) {\n  var dimension = _dimension(service)\n\n  var columnFunc = column\n  columnFunc.find = findColumn\n\n  return columnFunc\n\n  function column(def) {\n    // Support groupAll dimension\n    if (_.isUndefined(def)) {\n      def = true\n    }\n\n    // Always deal in bulk.  Like Costco!\n    if (!_.isArray(def)) {\n      def = [def]\n    }\n\n    // Mapp all column creation, wait for all to settle, then return the instance\n    return Promise.all(_.map(def, makeColumn))\n      .then(function () {\n        return service\n      })\n  }\n\n  function findColumn(d) {\n    return _.find(service.columns, function (c) {\n      if (_.isArray(d)) {\n        return !_.xor(c.key, d).length\n      }\n      return c.key === d\n    })\n  }\n\n  function getType(d) {\n    if (_.isNumber(d)) {\n      return 'number'\n    }\n    if (_.isBoolean(d)) {\n      return 'bool'\n    }\n    if (_.isArray(d)) {\n      return 'array'\n    }\n    if (_.isObject(d)) {\n      return 'object'\n    }\n    return 'string'\n  }\n\n  function makeColumn(d) {\n    var column = _.isObject(d) ? d : {\n      key: d,\n    }\n\n    var existing = findColumn(column.key)\n\n    if (existing) {\n      existing.temporary = false\n      if (existing.dynamicReference) {\n        existing.dynamicReference = false\n      }\n      return existing.promise\n        .then(function () {\n          return service\n        })\n    }\n\n    // for storing info about queries and post aggregations\n    column.queries = []\n    service.columns.push(column)\n\n    column.promise = new Promise(function (resolve, reject) {\n      try {\n        resolve(service.cf.all())\n      } catch (err) {\n        reject(err)\n      }\n    })\n      .then(function (all) {\n        var sample\n\n        // Complex column Keys\n        if (_.isFunction(column.key)) {\n          column.complex = 'function'\n          sample = column.key(all[0])\n        } else if (_.isString(column.key) && (column.key.indexOf('.') > -1 || column.key.indexOf('[') > -1)) {\n          column.complex = 'string'\n          sample = _.get(all[0], column.key)\n        } else if (_.isArray(column.key)) {\n          column.complex = 'array'\n          sample = _.values(_.pick(all[0], column.key))\n          if (sample.length !== column.key.length) {\n            throw new Error('Column key does not exist in data!', column.key)\n          }\n        } else {\n          sample = all[0][column.key]\n        }\n\n        // Index Column\n        if (!column.complex && column.key !== true && typeof sample === 'undefined') {\n          throw new Error('Column key does not exist in data!', column.key)\n        }\n\n        // If the column exists, let's at least make sure it's marked\n        // as permanent. There is a slight chance it exists because\n        // of a filter, and the user decides to make it permanent\n\n        if (column.key === true) {\n          column.type = 'all'\n        } else if (column.complex) {\n          column.type = 'complex'\n        } else if (column.array) {\n          column.type = 'array'\n        } else {\n          column.type = getType(sample)\n        }\n\n        return dimension.make(column.key, column.type, column.complex)\n      })\n      .then(function (dim) {\n        column.dimension = dim\n        column.filterCount = 0\n        var stopListeningForData = service.onDataChange(buildColumnKeys)\n        column.removeListeners = [stopListeningForData]\n\n        return buildColumnKeys()\n\n        // Build the columnKeys\n        function buildColumnKeys(changes) {\n          if (column.key === true) {\n            return Promise.resolve()\n          }\n\n          var accessor = dimension.makeAccessor(column.key, column.complex)\n          column.values = column.values || []\n\n          return new Promise(function (resolve, reject) {\n            try {\n              if (changes && changes.added) {\n                resolve(changes.added)\n              } else {\n                resolve(column.dimension.bottom(Infinity))\n              }\n            } catch (err) {\n              reject(err)\n            }\n          })\n            .then(function (rows) {\n              var newValues\n              if (column.complex === 'string' || column.complex === 'function') {\n                newValues = _.map(rows, accessor)\n                // console.log(rows, accessor.toString(), newValues)\n              } else if (column.type === 'array') {\n                newValues = _.flatten(_.map(rows, accessor))\n              } else {\n                newValues = _.map(rows, accessor)\n              }\n              column.values = _.uniq(column.values.concat(newValues))\n            })\n        }\n      })\n\n    return column.promise\n      .then(function () {\n        return service\n      })\n  }\n}\n","import _ from './lodash'\n\nexport default function (service) {\n  return {\n    make: make,\n    makeAccessor: makeAccessor,\n  }\n\n  function make(key, type, complex) {\n    var accessor = makeAccessor(key, complex)\n    // Promise.resolve will handle promises or non promises, so\n    // this crossfilter async is supported if present\n    return Promise.resolve(service.cf.dimension(accessor, type === 'array'))\n  }\n\n  function makeAccessor(key, complex) {\n    var accessorFunction\n\n    if (complex === 'string') {\n      accessorFunction = function (d) {\n        return _.get(d, key)\n      }\n    } else if (complex === 'function') {\n      accessorFunction = key\n    } else if (complex === 'array') {\n      var arrayString = _.map(key, function (k) {\n        return 'd[\\'' + k + '\\']'\n      })\n      accessorFunction = new Function('d', String('return ' + JSON.stringify(arrayString).replace(/\"/g, '')))  // eslint-disable-line  no-new-func\n    } else {\n      accessorFunction =\n        // Index Dimension\n        key === true ? function accessor(d, i) {\n          return i\n        } :\n          // Value Accessor Dimension\n          function (d) {\n            return d[key]\n          }\n    }\n    return accessorFunction\n  }\n}\n","var filter = {\n\t// The big idea here is that you give us a filter function to run on values,\n\t// a 'prior' reducer to run (just like the rest of the standard reducers),\n\t// and a reference to the last reducer (called 'skip' below) defined before\n\t// the most recent chain of reducers.  This supports individual filters for\n\t// each .value('...') chain that you add to your reducer.\n\tadd: function (filter, prior, skip) {\n\t\treturn function (p, v, nf) {\n\t\t\tif (filter(v, nf)) {\n\t\t\t\tif (prior) prior(p, v, nf);\n\t\t\t} else {\n\t\t\t\tif (skip) skip(p, v, nf);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (filter, prior, skip) {\n\t\treturn function (p, v, nf) {\n\t\t\tif (filter(v, nf)) {\n\t\t\t\tif (prior) prior(p, v, nf);\n\t\t\t} else {\n\t\t\t\tif (skip) skip(p, v, nf);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default filter;\n","var count = {\n\tadd: function(prior, path, propName) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p)[propName]++;\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function(prior, path, propName) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p)[propName]--;\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function(prior, path, propName) {\n\t\treturn function (p) {\n\t\t\tif(prior) p = prior(p);\n\t\t\t// if(p === undefined) p = {};\n\t\t\tpath(p)[propName] = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default count;","var sum = {\n\tadd: function (a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p).sum = path(p).sum + a(v);\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p).sum = path(p).sum - a(v);\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).sum = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default sum;","var avg = {\n\tadd: function (a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tif(path(p).count > 0) {\n\t\t\t\tpath(p).avg = path(p).sum / path(p).count;\n\t\t\t} else {\n\t\t\t\tpath(p).avg = 0;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tif(path(p).count > 0) {\n\t\t\t\tpath(p).avg = path(p).sum / path(p).count;\n\t\t\t} else {\n\t\t\t\tpath(p).avg = 0;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).avg = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default avg;","var median = {\n\tadd: function (prior, path) {\n\t\tvar half;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\n\t\t\thalf = Math.floor(path(p).valueList.length/2);\n \n\t\t\tif(path(p).valueList.length % 2) {\n\t\t\t\tpath(p).median = path(p).valueList[half];\n\t\t\t} else {\n\t\t\t\tpath(p).median = (path(p).valueList[half-1] + path(p).valueList[half]) / 2.0;\n\t\t\t}\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (prior, path) {\n\t\tvar half;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\n\t\t\thalf = Math.floor(path(p).valueList.length/2);\n\n\t\t\t// Check for undefined.\n\t\t\tif(path(p).valueList.length === 0) {\n\t\t\t\tpath(p).median = undefined;\n\t\t\t\treturn p;\n\t\t\t}\n \n\t\t\tif(path(p).valueList.length === 1 || path(p).valueList.length % 2) {\n\t\t\t\tpath(p).median = path(p).valueList[half];\n\t\t\t} else {\n\t\t\t\tpath(p).median = (path(p).valueList[half-1] + path(p).valueList[half]) / 2.0;\n\t\t\t}\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).median = undefined;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default median;","var min = {\n\tadd: function (prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n \n\t\t\tpath(p).min = path(p).valueList[0];\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\n\t\t\t// Check for undefined.\n\t\t\tif(path(p).valueList.length === 0) {\n\t\t\t\tpath(p).min = undefined;\n\t\t\t\treturn p;\n\t\t\t}\n \n\t\t\tpath(p).min = path(p).valueList[0];\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).min = undefined;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default min;","var max = {\n\tadd: function (prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n \n\t\t\tpath(p).max = path(p).valueList[path(p).valueList.length - 1];\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\n\t\t\t// Check for undefined.\n\t\t\tif(path(p).valueList.length === 0) {\n\t\t\t\tpath(p).max = undefined;\n\t\t\t\treturn p;\n\t\t\t}\n \n\t\t\tpath(p).max = path(p).valueList[path(p).valueList.length - 1];\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).max = undefined;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default max;","if (typeof Uint8Array !== \"undefined\") {\n  var array8 = function(n) { return new Uint8Array(n); };\n  var array16 = function(n) { return new Uint16Array(n); };\n  var array32 = function(n) { return new Uint32Array(n); };\n\n  var arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  var arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = array16(array.length); break;\n      case 32: copy = array32(array.length); break;\n      default: throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\n\n// An arbitrarily-wide array of bitmasks\nfunction bitarray(n) {\n  this.length = n;\n  this.subarrays = 1;\n  this.width = 8;\n  this.masks = {\n    0: 0\n  }\n\n  this[0] = array8(n);\n}\n\nbitarray.prototype.lengthen = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i] = arrayLengthen(this[i], n);\n  }\n  this.length = n;\n};\n\n// Reserve a new bit index in the array, returns {offset, one}\nbitarray.prototype.add = function() {\n  var m, w, one, i, len;\n\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    m = this.masks[i];\n    w = this.width - (32 * i);\n    // isolate the rightmost zero bit and return it as an unsigned int of 32 bits, if NaN or -1, return a 0 \n    one = (~m & (m + 1)) >>> 0;\n\n    if (w >= 32 && !one) {\n      continue;\n    }\n\n    if (w < 32 && (one & (1 << w))) {\n      // widen this subarray\n      this[i] = arrayWiden(this[i], w <<= 1);\n      this.width = 32 * i + w;\n    }\n\n    this.masks[i] |= one;\n\n    return {\n      offset: i,\n      one: one\n    };\n  }\n\n  // add a new subarray\n  this[this.subarrays] = array8(this.length);\n  this.masks[this.subarrays] = 1;\n  this.width += 8;\n  return {\n    offset: this.subarrays++,\n    one: 1\n  };\n};\n\n// Copy record from index src to index dest\nbitarray.prototype.copy = function(dest, src) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i][dest] = this[i][src];\n  }\n};\n\n// Truncate the array to the given length\nbitarray.prototype.truncate = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    for (var j = this.length - 1; j >= n; j--) {\n      this[i][j] = 0;\n    }\n  }\n  this.length = n;\n};\n\n// Checks that all bits for the given index are 0\nbitarray.prototype.zero = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for possibly one\nbitarray.prototype.zeroExcept = function(n, offset, zero) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (i === offset ? this[i][n] & zero : this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given indez are 0 except for the specified mask.\n// The mask should be an array of the same size as the filter subarrays width.\nbitarray.prototype.zeroExceptMask = function(n, mask) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] & mask[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks that only the specified bit is set for the given index\nbitarray.prototype.only = function(n, offset, one) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] != (i === offset ? one : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that only the specified bit is set for the given index except for possibly one other\nbitarray.prototype.onlyExcept = function(n, offset, zero, onlyOffset, onlyOne) {\n  var mask;\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    mask = this[i][n];\n    if (i === offset)\n      mask &= zero;\n    if (mask != (i === onlyOffset ? onlyOne : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport default {\n  array8: arrayUntyped,\n  array16: arrayUntyped,\n  array32: arrayUntyped,\n  arrayLengthen: arrayLengthenUntyped,\n  arrayWiden: arrayWidenUntyped,\n  bitarray: bitarray\n};\n","const filterExact = (bisect, value) => {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nconst filterRange = (bisect, range) => {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nconst filterAll = values => {\n  return [0, values.length];\n}\n\nexport default {\n  filterExact,\n  filterRange,\n  filterAll\n};\n","export default d => {\n  return d;\n};\n","export default () =>  {\n  return null;\n}\n","export default () => {\n  return 0;\n}\n","import identity from './identity';\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\n\nconst h = heap_by(identity);\nh.by = heap_by;\n\nexport default h;\n","import identity from './identity';\nimport xFilterHeap from './heap';\n\nfunction heapselect_by(f) {\n  var heap = xFilterHeap.by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\n\n\nconst h = heapselect_by(identity);\nh.by = heapselect_by; // assign the raw function to the export as well\n\nexport default h;\n","import identity from './identity';\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\n\nconst bisect = bisect_by(identity);\nbisect.by = bisect_by; // assign the raw function to the export as well\n\nexport default bisect;\n\n","import identity from './identity';\n\nfunction insertionsort_by(f) {\n\n  function insertionsort(a, lo, hi) {\n    for (var i = lo + 1; i < hi; ++i) {\n      for (var j = i, t = a[i], x = f(t); j > lo && f(a[j - 1]) > x; --j) {\n        a[j] = a[j - 1];\n      }\n      a[j] = t;\n    }\n    return a;\n  }\n\n  return insertionsort;\n}\n\nconst insertion = insertionsort_by(identity);\ninsertion.by = insertionsort_by;\n\nexport default insertion;\n","export default (array, index, deep) => {\n  for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\n","import identity from './identity';\nimport xFilterInsertionsort from './insertionsort';\n\n// Algorithm designed by Vladimir Yaroslavskiy.\n// Implementation based on the Dart project; see NOTICE and AUTHORS for details.\n\nfunction quicksort_by(f) {\n  var insertionsort = xFilterInsertionsort.by(f);\n\n  function sort(a, lo, hi) {\n    return (hi - lo < quicksort_sizeThreshold\n        ? insertionsort\n        : quicksort)(a, lo, hi);\n  }\n\n  function quicksort(a, lo, hi) {\n    // Compute the two pivots by looking at 5 elements.\n    var sixth = (hi - lo) / 6 | 0,\n        i1 = lo + sixth,\n        i5 = hi - 1 - sixth,\n        i3 = lo + hi - 1 >> 1,  // The midpoint.\n        i2 = i3 - sixth,\n        i4 = i3 + sixth;\n\n    var e1 = a[i1], x1 = f(e1),\n        e2 = a[i2], x2 = f(e2),\n        e3 = a[i3], x3 = f(e3),\n        e4 = a[i4], x4 = f(e4),\n        e5 = a[i5], x5 = f(e5);\n\n    var t;\n\n    // Sort the selected 5 elements using a sorting network.\n    if (x1 > x2) t = e1, e1 = e2, e2 = t, t = x1, x1 = x2, x2 = t;\n    if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n    if (x1 > x3) t = e1, e1 = e3, e3 = t, t = x1, x1 = x3, x3 = t;\n    if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n    if (x1 > x4) t = e1, e1 = e4, e4 = t, t = x1, x1 = x4, x4 = t;\n    if (x3 > x4) t = e3, e3 = e4, e4 = t, t = x3, x3 = x4, x4 = t;\n    if (x2 > x5) t = e2, e2 = e5, e5 = t, t = x2, x2 = x5, x5 = t;\n    if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n    if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n\n    var pivot1 = e2, pivotValue1 = x2,\n        pivot2 = e4, pivotValue2 = x4;\n\n    // e2 and e4 have been saved in the pivot variables. They will be written\n    // back, once the partitioning is finished.\n    a[i1] = e1;\n    a[i2] = a[lo];\n    a[i3] = e3;\n    a[i4] = a[hi - 1];\n    a[i5] = e5;\n\n    var less = lo + 1,   // First element in the middle partition.\n        great = hi - 2;  // Last element in the middle partition.\n\n    // Note that for value comparison, <, <=, >= and > coerce to a primitive via\n    // Object.prototype.valueOf; == and === do not, so in order to be consistent\n    // with natural order (such as for Date objects), we must do two compares.\n    var pivotsEqual = pivotValue1 <= pivotValue2 && pivotValue1 >= pivotValue2;\n    if (pivotsEqual) {\n\n      // Degenerated case where the partitioning becomes a dutch national flag\n      // problem.\n      //\n      // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]\n      //  ^             ^          ^             ^            ^\n      // left         less         k           great         right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1) for x in ]left, less[ : x < pivot.\n      //   2) for x in [less, k[ : x == pivot.\n      //   3) for x in ]great, right[ : x > pivot.\n      for (var k = less; k <= great; ++k) {\n        var ek = a[k], xk = f(ek);\n        if (xk < pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          ++less;\n        } else if (xk > pivotValue1) {\n\n          // Find the first element <= pivot in the range [k - 1, great] and\n          // put [:ek:] there. We know that such an element must exist:\n          // When k == less, then el3 (which is equal to pivot) lies in the\n          // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.\n          // Note that in the latter case invariant 2 will be violated for a\n          // short amount of time. The invariant will be restored when the\n          // pivots are put into their final positions.\n          /* eslint no-constant-condition: 0 */\n          while (true) {\n            var greatValue = f(a[great]);\n            if (greatValue > pivotValue1) {\n              great--;\n              // This is the only location in the while-loop where a new\n              // iteration is started.\n              continue;\n            } else if (greatValue < pivotValue1) {\n              // Triple exchange.\n              a[k] = a[less];\n              a[less++] = a[great];\n              a[great--] = ek;\n              break;\n            } else {\n              a[k] = a[great];\n              a[great--] = ek;\n              // Note: if great < k then we will exit the outer loop and fix\n              // invariant 2 (which we just violated).\n              break;\n            }\n          }\n        }\n      }\n    } else {\n\n      // We partition the list into three parts:\n      //  1. < pivot1\n      //  2. >= pivot1 && <= pivot2\n      //  3. > pivot2\n      //\n      // During the loop we have:\n      // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]\n      //  ^            ^                        ^              ^             ^\n      // left         less                     k              great        right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1. for x in ]left, less[ : x < pivot1\n      //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2\n      //   3. for x in ]great, right[ : x > pivot2\n      (function () { // isolate scope\n      for (var k = less; k <= great; k++) {\n        var ek = a[k], xk = f(ek);\n        if (xk < pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          ++less;\n        } else {\n          if (xk > pivotValue2) {\n            while (true) {\n              var greatValue = f(a[great]);\n              if (greatValue > pivotValue2) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] <= pivot2.\n                if (greatValue < pivotValue1) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ek;\n                } else {\n                  // a[great] >= pivot1.\n                  a[k] = a[great];\n                  a[great--] = ek;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n      })(); // isolate scope\n    }\n\n    // Move pivots into their final positions.\n    // We shrunk the list from both sides (a[left] and a[right] have\n    // meaningless values in them) and now we move elements from the first\n    // and third partition into these locations so that we can store the\n    // pivots.\n    a[lo] = a[less - 1];\n    a[less - 1] = pivot1;\n    a[hi - 1] = a[great + 1];\n    a[great + 1] = pivot2;\n\n    // The list is now partitioned into three partitions:\n    // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]\n    //  ^            ^                        ^             ^\n    // left         less                     great        right\n\n    // Recursive descent. (Don't include the pivot values.)\n    sort(a, lo, less - 1);\n    sort(a, great + 2, hi);\n\n    if (pivotsEqual) {\n      // All elements in the second partition are equal to the pivot. No\n      // need to sort them.\n      return a;\n    }\n\n    // In theory it should be enough to call _doSort recursively on the second\n    // partition.\n    // The Android source however removes the pivot elements from the recursive\n    // call if the second partition is too large (more than 2/3 of the list).\n    if (less < i1 && great > i5) {\n\n      (function () { // isolate scope\n      var lessValue, greatValue;\n      while ((lessValue = f(a[less])) <= pivotValue1 && lessValue >= pivotValue1) ++less;\n      while ((greatValue = f(a[great])) <= pivotValue2 && greatValue >= pivotValue2) --great;\n\n      // Copy paste of the previous 3-way partitioning with adaptions.\n      //\n      // We partition the list into three parts:\n      //  1. == pivot1\n      //  2. > pivot1 && < pivot2\n      //  3. == pivot2\n      //\n      // During the loop we have:\n      // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]\n      //              ^                      ^              ^\n      //            less                     k              great\n      //\n      // Invariants:\n      //   1. for x in [ *, less[ : x == pivot1\n      //   2. for x in [less, k[ : pivot1 < x && x < pivot2\n      //   3. for x in ]great, * ] : x == pivot2\n      for (var k = less; k <= great; k++) {\n        var ek = a[k], xk = f(ek);\n        if (xk <= pivotValue1 && xk >= pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          less++;\n        } else {\n          if (xk <= pivotValue2 && xk >= pivotValue2) {\n            /* eslint no-constant-condition: 0 */\n            while (true) {\n              greatValue = f(a[great]);\n              if (greatValue <= pivotValue2 && greatValue >= pivotValue2) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] < pivot2.\n                if (greatValue < pivotValue1) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ek;\n                } else {\n                  // a[great] == pivot1.\n                  a[k] = a[great];\n                  a[great--] = ek;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n      })(); // isolate scope\n\n    }\n\n    // The second partition has now been cleared of pivot elements and looks\n    // as follows:\n    // [  *  |  > pivot1 && < pivot2  | * ]\n    //        ^                      ^\n    //       less                  great\n    // Sort the second partition using recursive descent.\n\n    // The second partition looks as follows:\n    // [  *  |  >= pivot1 && <= pivot2  | * ]\n    //        ^                        ^\n    //       less                    great\n    // Simply sort it by recursive descent.\n\n    return sort(a, less, great + 1);\n  }\n\n  return sort;\n}\n\nvar quicksort_sizeThreshold = 32;\n\nconst q = quicksort_by(identity);\nq.by = quicksort_by;\n\nexport default q;\n","const reduceIncrement = p => {\n  return p + 1;\n}\n\nconst reduceDecrement = p => {\n  return p - 1;\n}\n\nconst reduceAdd = f => {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nconst reduceSubtract = f => {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\n\nexport default {\n  reduceIncrement,\n  reduceDecrement,\n  reduceAdd,\n  reduceSubtract\n};\n","import deep from \"@ranfdev/deepobj\"\n// Note(cg): result was previsouly using lodash.result, not ESM compatible.\n \nconst get = (obj, prop) => {\n  const value = obj[prop];\n  return (typeof value === 'function') ? value.call(obj) : value;\n}\n\n/**\n * get value of object at a deep path.\n * if the resolved value is a function,\n * it's invoked with the `this` binding of \n * its parent object and its result is returned. \n *  \n * @param  {Object} obj  the object (e.g. { 'a': [{ 'b': { 'c1': 3, 'c2': 4} }], 'd': {e:1} }; )\n * @param  {String} path deep path (e.g. `d.e`` or `a[0].b.c1`. Dot notation (a.0.b)is also supported)\n * @return {Any}      the resolved value\n */\nconst reg = /\\[([\\w\\d]+)\\]/g;\nexport default (obj, path) => {\n  return deep(get, obj, path.replace(reg, '.$1'))\n}\n","import xfilterArray from './array';\nimport xfilterFilter from './filter';\nimport cr_identity from './identity';\nimport cr_null from './null';\nimport cr_zero from './zero';\nimport xfilterHeapselect from './heapselect';\nimport xfilterHeap from './heap';\nimport bisect from './bisect';\nimport insertionsort from './insertionsort';\nimport permute from './permute';\nimport quicksort from './quicksort';\nimport xfilterReduce from './reduce';\nimport result from './result';\n\n// constants\nvar REMOVED_INDEX = -1;\n\ncrossfilter.heap = xfilterHeap;\ncrossfilter.heapselect = xfilterHeapselect;\ncrossfilter.bisect = bisect;\ncrossfilter.insertionsort = insertionsort;\ncrossfilter.permute = permute;\ncrossfilter.quicksort = quicksort;\nexport default crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size,\n    all: all,\n    allFiltered: allFiltered,\n    onChange: onChange,\n    isElementFiltered: isElementFiltered\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      filters, // 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = [], // when data is removed\n      callbacks = [];\n\n  filters = new xfilterArray.bitarray(0);\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add…\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters.lengthen(n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n      triggerOnChange('dataAdded');\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters, or if a predicate function is passed,\n  // removes all records matching the predicate (ignoring filters).\n  function removeData(predicate) {\n    var // Mapping from old record indexes to new indexes (after records removed)\n        newIndex = cr_index(n, n),\n        removed = [],\n        usePred = typeof predicate === 'function',\n        shouldRemove = function (i) {\n          return usePred ? predicate(data[i], i) : filters.zero(i)\n        };\n\n    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n      if ( shouldRemove(index1) ) {\n        removed.push(index1);\n        newIndex[index1] = REMOVED_INDEX;\n      } else {\n        newIndex[index1] = index2++;\n      }\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(-1, -1, [], removed, true); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n      if ( newIndex[index3] !== REMOVED_INDEX ) {\n        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n        ++index4;\n      }\n    }\n\n    data.length = n = index4;\n    filters.truncate(index4);\n    triggerOnChange('dataRemoved');\n  }\n\n  function maskForDimensions(dimensions) {\n    var n,\n        d,\n        len,\n        id,\n        mask = Array(filters.subarrays);\n    for (n = 0; n < filters.subarrays; n++) { mask[n] = ~0; }\n    for (d = 0, len = dimensions.length; d < len; d++) {\n      // The top bits of the ID are the subarray offset and the lower bits are the bit\n      // offset of the \"one\" mask.\n      id = dimensions[d].id();\n      mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n    }\n    return mask;\n  }\n\n  // Return true if the data element at index i is filtered IN.\n  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n  function isElementFiltered(i, ignore_dimensions) {\n    var mask = maskForDimensions(ignore_dimensions || []);\n    return filters.zeroExceptMask(i,mask);\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value, iterable) {\n\n    if (typeof value === 'string') {\n      var accessorPath = value;\n      value = function(d) { return result(d, accessorPath); };\n    }\n\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      currentFilter: currentFilter,\n      hasCurrentFilter: hasCurrentFilter,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose, // for backwards-compatibility\n      accessor: value,\n      id: function() { return id; }\n    };\n\n    var one, // lowest unset bit as mask, e.g., 00001000\n        zero, // inverted one, e.g., 11110111\n        offset, // offset into the filters arrays\n        id, // unique ID for this dimension (reused when dimensions are disposed)\n        values, // sorted, cached array\n        index, // maps sorted value index -> record index (in data)\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        iterablesIndexCount,\n        newIterablesIndexCount,\n        iterablesIndexFilterStatus,\n        newIterablesIndexFilterStatus,\n        iterablesEmptyRows = [],\n        sort = quicksort.by(function(i) { return newValues[i]; }),\n        refilter = xfilterFilter.filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        filterValue, // the value used for filtering (value, array, function or undefined)\n        filterValuePresent, // true if filterValue contains something\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0,\n        t = 0,\n        k;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Add a new dimension in the filter bitmap and store the offset and bitmask.\n    var tmp = filters.add();\n    offset = tmp.offset;\n    one = tmp.one;\n    zero = ~one;\n\n    // Create a unique ID for the dimension\n    // IDs will be re-used if dimensions are disposed.\n    // For internal use the ID is the subarray offset shifted left 7 bits or'd with the\n    // bit offset of the set bit in the dimension's \"one\" mask.\n    id = (offset << 7) | (Math.log(one) / Math.log(2));\n\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n\n      if (iterable){\n        // Count all the values\n        t = 0;\n        j = 0;\n        k = [];\n\n        for (var i0 = 0; i0 < newData.length; i0++) {\n          for(j = 0, k = value(newData[i0]); j < k.length; j++) {\n            t++;\n          }\n        }\n\n        newValues = [];\n        newIterablesIndexCount = cr_range(newData.length);\n        newIterablesIndexFilterStatus = cr_index(t,1);\n        var unsortedIndex = cr_range(t);\n\n        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n          k = value(newData[index1])\n          //\n          if(!k.length){\n            newIterablesIndexCount[index1] = 0;\n            iterablesEmptyRows.push(index1 + n0);\n            continue;\n          }\n          newIterablesIndexCount[index1] = k.length\n          for (j = 0; j < k.length; j++) {\n            newValues.push(k[j]);\n            unsortedIndex[l] = index1;\n            l++;\n          }\n        }\n\n        // Create the Sort map used to sort both the values and the valueToData indices\n        var sortMap = sort(cr_range(t), 0, t);\n\n        // Use the sortMap to sort the newValues\n        newValues = permute(newValues, sortMap);\n\n\n        // Use the sortMap to sort the unsortedIndex map\n        // newIndex should be a map of sortedValue -> crossfilterData\n        newIndex = permute(unsortedIndex, sortMap)\n\n      } else{\n        // Permute new values into natural order using a standard sorted index.\n        newValues = newData.map(value);\n        newIndex = sort(cr_range(n1), 0, n1);\n        newValues = permute(newValues, newIndex);\n      }\n\n      if(iterable) {\n        n1 = t;\n      }\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];\n      if (refilterFunction) {\n        for (var index2 = 0; index2 < n1; ++index2) {\n          if (!refilterFunction(newValues[index2], index2)) {\n            filters[offset][newIndex[index2] + n0] |= one;\n            if(iterable) newIterablesIndexFilterStatus[index2] = 1;\n          }\n        }\n      } else {\n        for (var index3 = 0; index3 < lo1; ++index3) {\n          filters[offset][newIndex[index3] + n0] |= one;\n          if(iterable) newIterablesIndexFilterStatus[index3] = 1;\n        }\n        for (var index4 = hi1; index4 < n1; ++index4) {\n          filters[offset][newIndex[index4] + n0] |= one;\n          if(iterable) newIterablesIndexFilterStatus[index4] = 1;\n        }\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        iterablesIndexCount = newIterablesIndexCount;\n        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n\n\n      var oldValues = values,\n        oldIndex = index,\n        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n        old_n0,\n        i1 = 0;\n\n      i0 = 0;\n\n      if(iterable){\n        old_n0 = n0\n        n0 = oldValues.length;\n        n1 = t\n      }\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = iterable ? new Array(n0 + n1) : new Array(n);\n      index = iterable ? new Array(n0 + n1) : cr_index(n, n);\n      if(iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);\n\n      // Concatenate the newIterablesIndexCount onto the old one.\n      if(iterable) {\n        var oldiiclength = iterablesIndexCount.length;\n        iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n        for(var j=0; j+oldiiclength < n; j++) {\n          iterablesIndexCount[j+oldiiclength] = newIterablesIndexCount[j];\n        }\n      }\n\n      // Merge the old and new sorted values, and old and new index.\n      var index5 = 0;\n      for (; i0 < n0 && i1 < n1; ++index5) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[index5] = oldValues[i0];\n          if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0++];\n        } else {\n          values[index5] = newValues[i1];\n          if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++index5) {\n        values[index5] = oldValues[i0];\n        if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n        index[index5] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++index5) {\n        values[index5] = newValues[i1];\n        if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      if (iterable) {\n        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n            i1++;\n          }\n        }\n        iterablesEmptyRows.length = i1;\n        for (i0 = 0, i1 = 0; i0 < n; i0++) {\n          if (reIndex[i0] !== REMOVED_INDEX) {\n            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n            i1++;\n          }\n        }\n        iterablesIndexCount.length = i1;\n      }\n      // Rewrite our index, overwriting removed values\n      var n0 = values.length;\n      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n        oldDataIndex = index[i];\n        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[oldDataIndex];\n          if (iterable) {\n            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n          }\n          ++j;\n        }\n      }\n      values.length = j;\n      if (iterable) iterablesIndexFilterStatus.length = j;\n      while (j < n0) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; }, bounds[0] === 0 && bounds[1] === values.length);\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [];\n\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      if(!iterable) {\n        // Flip filters normally.\n\n        for(i=0; i<added.length; i++) {\n          filters[offset][added[i]] ^= one;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          filters[offset][removed[i]] ^= one;\n        }\n\n      } else {\n        // For iterables, we need to figure out if the row has been completely removed vs partially included\n        // Only count a row as added if it is not already being aggregated. Only count a row\n        // as removed if the last element being aggregated is removed.\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          iterablesIndexCount[added[i]]++\n          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n          if(iterablesIndexCount[added[i]] === 1) {\n            filters[offset][added[i]] ^= one;\n            newAdded.push(added[i]);\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          iterablesIndexCount[removed[i]]--\n          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n          if(iterablesIndexCount[removed[i]] === 0) {\n            filters[offset][removed[i]] ^= one;\n            newRemoved.push(removed[i]);\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(bounds[0] === 0 && bounds[1] === values.length) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      filterValue = value;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      filterValue = range;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      filterValue = undefined;\n      filterValuePresent = false;\n      return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      filterValue = f;\n      filterValuePresent = true;\n      \n      refilterFunction = f;\n      refilter = xfilterFilter.filterAll;\n\n      filterIndexFunction(f, false);\n\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f, filterAll) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [],\n          indexLength = values.length;\n\n      if(!iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) added.push(k);\n            else removed.push(k);\n          }\n        }\n      }\n\n      if(iterable) {\n        for(i=0; i < indexLength; ++i) {\n          if(f(values[i], i)) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          } else {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n      }\n\n      if(!iterable) {\n        for(i=0; i<added.length; i++) {\n          if(filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          if(!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n        }\n      } else {\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          // First check this particular value needs to be added\n          if(iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n            iterablesIndexCount[added[i]]++\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n            if(iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          // First check this particular value needs to be removed\n          if(iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n            iterablesIndexCount[removed[i]]--\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n            if(iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n    }\n    \n    function currentFilter() {\n      return filterValue;\n    }\n    \n    function hasCurrentFilter() {\n      return filterValuePresent;\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k, top_offset) {\n      var array = [],\n          i = hi0,\n          j,\n          toSkip = 0;\n\n      if(top_offset && top_offset > 0) toSkip = top_offset;\n\n      while (--i >= lo0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n      }\n\n      if(iterable){\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          // Add row with empty iterable column at the end\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k, bottom_offset) {\n      var array = [],\n          i,\n          j,\n          toSkip = 0;\n\n      if(bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n\n      if(iterable) {\n        // Add row with empty iterable column at the top\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      i = lo0;\n\n      while (i < hi0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id ↦ group id\n          groupWidth = 8,\n          groupCapacity = capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = cr_null,\n          reset = cr_null,\n          resetNeeded = true,\n          groupAll = key === cr_null,\n          n0old;\n\n      if (arguments.length < 1) key = cr_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n\n        if(iterable) {\n          n0old = n0\n          n0 = values.length - newValues.length\n          n1 = newValues.length;\n        }\n\n        var oldGroups = groups,\n            reIndex = iterable ? [] : cr_index(k, groupCapacity),\n            add = reduceAdd,\n            remove = reduceRemove,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = cr_null;\n        if (resetNeeded) remove = initial = cr_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        if(iterable){\n          groupIndex = k0 ? groupIndex : [];\n        }\n        else{\n          groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);\n        }\n\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain…\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            g0 = oldGroups[++i0];\n            if (g0) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n\n          while (x1 <= x) {\n            j = newIndex[i1] + (iterable ? n0old : n0)\n\n\n            if(iterable){\n              if(groupIndex[j]){\n                groupIndex[j].push(k)\n              }\n              else{\n                groupIndex[j] = [k]\n              }\n            }\n            else{\n              groupIndex[j] = k;\n            }\n\n            // Always add new values to groups. Only remove when not in filter.\n            // This gives groups full information on data life-cycle.\n            g.value = add(g.value, data[j], true);\n            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater th1an all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n\n        // Fill in gaps with empty arrays where there may have been rows with empty iterables\n        if(iterable){\n          for (var index1 = 0; index1 < n; index1++) {\n            if(!groupIndex[index1]){\n              groupIndex[index1] = [];\n            }\n          }\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if(k > i0){\n          if(iterable){\n            for (i0 = 0; i0 < n0old; ++i0) {\n              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n              }\n            }\n          }\n          else{\n            for (i0 = 0; i0 < n0; ++i0) {\n              groupIndex[i0] = reIndex[groupIndex[i0]];\n            }\n          }\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1 || iterable) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = cr_null;\n            reset = cr_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if(iterable){\n            k++\n            return\n          }\n          if (++k === groupCapacity) {\n            reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n            groupCapacity = capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData(reIndex) {\n        if (k > 1 || iterable) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = cr_index(oldK, oldK),\n              i,\n              i0,\n              j;\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          if (!iterable) {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            }\n          } else {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                groupIndex[j] = groupIndex[i];\n                for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                  seenGroups[groupIndex[j][i0]] = 1;\n                }\n                ++j;\n              }\n            }\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1 || iterable) {\n            // Reindex the group index using seenGroups to find the new index.\n            if (!iterable) {\n              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n            } else {\n              for (i = 0; i < j; ++i) {\n                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                }\n              }\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = cr_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = cr_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            j,\n            k,\n            n,\n            g;\n\n        if(iterable){\n          // Add the added values.\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceAdd(g.value, data[k], false, j);\n              }\n            }\n          }\n\n          // Remove the removed values.\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceRemove(g.value, data[k], notFilter, j);\n              }\n            }\n          }\n          return;\n        }\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            j,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        if(iterable){\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < groupIndex[i].length; j++) {\n              g = groups[groupIndex[i][j]];\n              g.value = reduceAdd(g.value, data[i], true, j);\n            }\n          }\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceRemove(g.value, data[i], false, j);\n              }\n            }\n          }\n          return;\n        }\n\n        for (i = 0; i < n; ++i) {\n          g = groups[groupIndex[i]];\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        for (i = 0; i < n; ++i) {\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = xfilterHeapselect.by(valueOf);\n        heap = xfilterHeap.by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(cr_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        i = dimensionGroups.indexOf(group);\n        if (i >= 0) dimensionGroups.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(cr_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      filters.masks[offset] &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Cycle through all the values.\n      for (i = n0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, filterOffset, added, removed, notFilter) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (filters.zero(k = added[i])) {\n          reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters.only(k = removed[i], filterOffset, filterOne)) {\n          reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      // Cycle through all the values.\n      for (i = 0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if it is filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i, 1);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i, 1);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  // Returns the raw row data contained in this crossfilter\n  function all(){\n    return data;\n  }\n\n  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n  function allFiltered(ignore_dimensions) {\n    var array = [],\n        i = 0,\n        mask = maskForDimensions(ignore_dimensions || []);\n\n      for (i = 0; i < n; i++) {\n        if (filters.zeroExceptMask(i, mask)) {\n          array.push(data[i]);\n        }\n      }\n\n      return array;\n  }\n\n  function onChange(cb){\n    if(typeof cb !== 'function'){\n      /* eslint no-console: 0 */\n      console.warn('onChange callback parameter must be a function!');\n      return;\n    }\n    callbacks.push(cb);\n    return function(){\n      callbacks.splice(callbacks.indexOf(cb), 1);\n    };\n  }\n\n  function triggerOnChange(eventName){\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](eventName);\n    }\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction cr_index(n, m) {\n  return (m < 0x101\n      ? xfilterArray.array8 : m < 0x10001\n      ? xfilterArray.array16\n      : xfilterArray.array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction cr_range(n) {\n  var range = cr_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n","import crossfilter from 'crossfilter2';\n\nvar value_count = {\n\tadd: function (a, prior, path) {\n\t\tvar i, curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\t// Not sure if this is more efficient than sorting.\n\t\t\ti = path(p).bisect(path(p).values, a(v), 0, path(p).values.length);\n\t\t\tcurr = path(p).values[i];\n\t\t\tif(curr && curr[0] === a(v)) {\n\t\t\t\t// Value already exists in the array - increment it\n\t\t\t\tcurr[1]++;\n\t\t\t} else {\n\t\t\t\t// Value doesn't exist - add it in form [value, 1]\n\t\t\t\tpath(p).values.splice(i, 0, [a(v), 1]);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\tvar i;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\ti = path(p).bisect(path(p).values, a(v), 0, path(p).values.length);\n\t\t\t// Value already exists or something has gone terribly wrong.\n\t\t\tpath(p).values[i][1]--;\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\t// Array[Array[value, count]]\n\t\t\tpath(p).values = [];\n\t\t\tpath(p).bisect = crossfilter.bisect.by(function(d) { return d[0]; }).left;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default value_count;","import crossfilter from 'crossfilter2';\n\nvar value_list = {\n\tadd: function (a, prior, path) {\n\t\tvar i;\n\t\tvar bisect = crossfilter.bisect.by(function(d) { return d; }).left;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\t// Not sure if this is more efficient than sorting.\n\t\t\ti = bisect(path(p).valueList, a(v), 0, path(p).valueList.length);\n\t\t\tpath(p).valueList.splice(i, 0, a(v));\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\tvar i;\n\t\tvar bisect = crossfilter.bisect.by(function(d) { return d; }).left;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\ti = bisect(path(p).valueList, a(v), 0, path(p).valueList.length);\n\t\t\t// Value already exists or something has gone terribly wrong.\n\t\t\tpath(p).valueList.splice(i, 1);\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).valueList = [];\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default value_list;","var exception_count = {\n\tadd: function (a, prior, path) {\n\t\tvar i, curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\t// Only count++ if the p.values array doesn't contain a(v) or if it's 0.\n\t\t\ti = path(p).bisect(path(p).values, a(v), 0, path(p).values.length);\n\t\t\tcurr = path(p).values[i];\n\t\t\tif((!curr || curr[0] !== a(v)) || curr[1] === 0) {\n\t\t\t\tpath(p).exceptionCount++;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\tvar i, curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\t// Only count-- if the p.values array contains a(v) value of 1.\n\t\t\ti = path(p).bisect(path(p).values, a(v), 0, path(p).values.length);\n\t\t\tcurr = path(p).values[i];\n\t\t\tif(curr && curr[0] === a(v) && curr[1] === 1) {\n\t\t\t\tpath(p).exceptionCount--;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).exceptionCount = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default exception_count;","var exception_sum = {\n\tadd: function (a, sum, prior, path) {\n\t\tvar i, curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\t// Only sum if the p.values array doesn't contain a(v) or if it's 0.\n\t\t\ti = path(p).bisect(path(p).values, a(v), 0, path(p).values.length);\n\t\t\tcurr = path(p).values[i];\n\t\t\tif((!curr || curr[0] !== a(v)) || curr[1] === 0) {\n\t\t\t\tpath(p).exceptionSum = path(p).exceptionSum + sum(v);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, sum, prior, path) {\n\t\tvar i, curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\t// Only sum if the p.values array contains a(v) value of 1.\n\t\t\ti = path(p).bisect(path(p).values, a(v), 0, path(p).values.length);\n\t\t\tcurr = path(p).values[i];\n\t\t\tif(curr && curr[0] === a(v) && curr[1] === 1) {\n\t\t\t\tpath(p).exceptionSum = path(p).exceptionSum - sum(v);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).exceptionSum = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default exception_sum;","import crossfilter from 'crossfilter2';\n\nvar histogram = {\n\tadd: function (a, prior, path) {\n\t\tvar bisect = crossfilter.bisect.by(function(d) { return d; }).left;\n\t\tvar bisectHisto = crossfilter.bisect.by(function(d) { return d.x; }).right;\n\t\tvar curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tcurr = path(p).histogram[bisectHisto(path(p).histogram, a(v), 0, path(p).histogram.length) - 1];\n\t\t\tcurr.y++;\n\t\t\tcurr.splice(bisect(curr, a(v), 0, curr.length), 0, a(v));\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\tvar bisect = crossfilter.bisect.by(function(d) { return d; }).left;\n\t\tvar bisectHisto = crossfilter.bisect.by(function(d) { return d.x; }).right;\n\t\tvar curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tcurr = path(p).histogram[bisectHisto(path(p).histogram, a(v), 0, path(p).histogram.length) - 1];\n\t\t\tcurr.y--;\n\t\t\tcurr.splice(bisect(curr, a(v), 0, curr.length), 1);\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (thresholds, prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).histogram = [];\n\t\t\tvar arr = [];\n\t\t\tfor(var i = 1; i < thresholds.length; i++) {\n\t\t\t\tarr = [];\n\t\t\t\tarr.x = thresholds[i - 1];\n\t\t\t\tarr.dx = (thresholds[i] - thresholds[i - 1]);\n\t\t\t\tarr.y = 0;\n\t\t\t\tpath(p).histogram.push(arr);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default histogram;","var sum_of_sq = {\n\tadd: function (a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p).sumOfSq = path(p).sumOfSq + a(v)*a(v);\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p).sumOfSq = path(p).sumOfSq - a(v)*a(v);\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).sumOfSq = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default sum_of_sq;","var std = {\n\tadd: function (prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tif(path(p).count > 0) {\n\t\t\t\tpath(p).std = 0.0;\n\t\t\t\tvar n = path(p).sumOfSq - path(p).sum*path(p).sum/path(p).count;\n\t\t\t\tif (n>0.0) path(p).std = Math.sqrt(n/(path(p).count-1));\n\t\t\t} else {\n\t\t\t\tpath(p).std = 0.0;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tif(path(p).count > 0) {\n\t\t\t\tpath(p).std = 0.0;\n\t\t\t\tvar n = path(p).sumOfSq - path(p).sum*path(p).sum/path(p).count;\n\t\t\t\tif (n>0.0) path(p).std = Math.sqrt(n/(path(p).count-1));\n\t\t\t} else {\n\t\t\t\tpath(p).std = 0;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).std = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default std;","import crossfilter from 'crossfilter2';\n\nvar nest = {\n\tadd: function (keyAccessors, prior, path) {\n\t\tvar i; // Current key accessor\n\t\tvar arrRef;\n\t\tvar newRef;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\n\t\t\tarrRef = path(p).nest;\n\t\t\tkeyAccessors.forEach(function(a) {\n\t\t\t\tnewRef = arrRef.filter(function(d) { return d.key === a(v); })[0];\n\t\t\t\tif(newRef) {\n\t\t\t\t\t// There is another level.\n\t\t\t\t\tarrRef = newRef.values;\n\t\t\t\t} else {\n\t\t\t\t\t// Next level doesn't yet exist so we create it.\n\t\t\t\t\tnewRef = [];\n\t\t\t\t\tarrRef.push({ key: a(v), values: newRef });\n\t\t\t\t\tarrRef = newRef;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tarrRef.push(v);\n\t\t\t\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (keyAccessors, prior, path) {\n\t\tvar arrRef;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\n\t\t\tarrRef = path(p).nest;\n\t\t\tkeyAccessors.forEach(function(a) {\n\t\t\t\tarrRef = arrRef.filter(function(d) { return d.key === a(v); })[0].values;\n\t\t\t});\n\n\t\t\t// Array contains an actual reference to the row, so just splice it out.\n\t\t\tarrRef.splice(arrRef.indexOf(v), 1);\n\n\t\t\t// If the leaf now has length 0 and it's not the base array remove it.\n\t\t\t// TODO\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).nest = [];\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default nest;","var alias = {\n\tinitial: function(prior, path, obj) {\n\t\treturn function (p) {\n\t\t\tif(prior) p = prior(p);\n\t\t\tfunction buildAliasFunction(key){\n\t\t\t\treturn function(){\n\t\t\t\t\treturn obj[key](path(p));\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor(var prop in obj) {\n\t\t\t\tpath(p)[prop] = buildAliasFunction(prop);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default alias;","var alias_prop = {\n\tadd: function (obj, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tfor(var prop in obj) {\n\t\t\t\tpath(p)[prop] = obj[prop](path(p),v);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default alias_prop;","var data_list = {\n\tadd: function(a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p).dataList.push(v);\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function(a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p).dataList.splice(path(p).dataList.indexOf(v), 1);\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function(prior, path) {\n\t\treturn function (p) {\n\t\t\tif(prior) p = prior(p);\n\t\t\tpath(p).dataList = [];\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default data_list;\n","var custom = {\n\tadd: function(prior, path, addFn) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\treturn addFn(p, v);\n\t\t};\n\t},\n\tremove: function(prior, path, removeFn) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\treturn removeFn(p, v);\n\t\t};\n\t},\n\tinitial: function(prior, path, initialFn) {\n\t\treturn function (p) {\t\n\t\t\tif(prior) p = prior(p);\n\t\t\treturn initialFn(p);\n\t\t};\n\t}\n};\n\nexport default custom;","import filter from './filter.js';\nimport count from './count.js';\nimport sum from './sum.js';\nimport avg from './avg.js';\nimport median from './median.js';\nimport min from './min.js';\nimport max from './max.js';\nimport value_count from './value-count.js';\nimport value_list from './value-list.js';\nimport exception_count from './exception-count.js';\nimport exception_sum from './exception-sum.js';\nimport histogram from './histogram.js';\nimport sum_of_sq from './sum-of-squares.js';\nimport std from './std.js';\nimport nest from './nest.js';\nimport alias from './alias.js';\nimport alias_prop from './aliasProp.js';\nimport data_list from './data-list.js';\nimport custom from './custom.js';\n\nfunction build_function(p, f, path) {\n\t// We have to build these functions in order. Eventually we can include dependency\n\t// information and create a dependency graph if the process becomes complex enough.\n\n\tif(!path) path = function (d) { return d; };\n\n\t// Keep track of the original reducers so that filtering can skip back to\n\t// them if this particular value is filtered out.\n\tvar origF = {\n\t\treduceAdd: f.reduceAdd,\n\t\treduceRemove: f.reduceRemove,\n\t\treduceInitial: f.reduceInitial\n\t};\n\n\tif(p.count || p.std) {\n    f.reduceAdd = count.add(f.reduceAdd, path, p.count);\n    f.reduceRemove = count.remove(f.reduceRemove, path, p.count);\n    f.reduceInitial = count.initial(f.reduceInitial, path, p.count);\n\t}\n\n\tif(p.sum) {\n\t\tf.reduceAdd = sum.add(p.sum, f.reduceAdd, path);\n\t\tf.reduceRemove = sum.remove(p.sum, f.reduceRemove, path);\n\t\tf.reduceInitial = sum.initial(f.reduceInitial, path);\n\t}\n\n\tif(p.avg) {\n\t\tif(!p.count || !p.sum) {\n\t\t\tconsole.error(\"You must set .count(true) and define a .sum(accessor) to use .avg(true).\");\n\t\t} else {\n\t\t\tf.reduceAdd = avg.add(p.sum, f.reduceAdd, path);\n\t\t\tf.reduceRemove = avg.remove(p.sum, f.reduceRemove, path);\n\t\t\tf.reduceInitial = avg.initial(f.reduceInitial, path);\n\t\t}\n\t}\n\n\t// The unique-only reducers come before the value_count reducers. They need to check if\n\t// the value is already in the values array on the group. They should only increment/decrement\n\t// counts if the value not in the array or the count on the value is 0.\n\tif(p.exceptionCount) {\n\t\tif(!p.exceptionAccessor) {\n\t\t\tconsole.error(\"You must define an .exception(accessor) to use .exceptionCount(true).\");\n\t\t} else {\n\t\t\tf.reduceAdd = exception_count.add(p.exceptionAccessor, f.reduceAdd, path);\n\t\t\tf.reduceRemove = exception_count.remove(p.exceptionAccessor, f.reduceRemove, path);\n\t\t\tf.reduceInitial = exception_count.initial(f.reduceInitial, path);\n\t\t}\n\t}\n\n\tif(p.exceptionSum) {\n\t\tif(!p.exceptionAccessor) {\n\t\t\tconsole.error(\"You must define an .exception(accessor) to use .exceptionSum(accessor).\");\n\t\t} else {\n\t\t\tf.reduceAdd = exception_sum.add(p.exceptionAccessor, p.exceptionSum, f.reduceAdd, path);\n\t\t\tf.reduceRemove = exception_sum.remove(p.exceptionAccessor, p.exceptionSum, f.reduceRemove, path);\n\t\t\tf.reduceInitial = exception_sum.initial(f.reduceInitial, path);\n\t\t}\n\t}\n\n\t// Maintain the values array.\n\tif(p.valueList || p.median || p.min || p.max) {\n\t\tf.reduceAdd = value_list.add(p.valueList, f.reduceAdd, path);\n\t\tf.reduceRemove = value_list.remove(p.valueList, f.reduceRemove, path);\n\t\tf.reduceInitial = value_list.initial(f.reduceInitial, path);\n\t}\n\n\t// Maintain the data array.\n\tif(p.dataList) {\n\t\tf.reduceAdd = data_list.add(p.dataList, f.reduceAdd, path);\n\t\tf.reduceRemove = data_list.remove(p.dataList, f.reduceRemove, path);\n\t\tf.reduceInitial = data_list.initial(f.reduceInitial, path);\n\t}\n\n\tif(p.median) {\n\t\tf.reduceAdd = median.add(f.reduceAdd, path);\n\t\tf.reduceRemove = median.remove(f.reduceRemove, path);\n\t\tf.reduceInitial = median.initial(f.reduceInitial, path);\n\t}\n\n\tif(p.min) {\n\t\tf.reduceAdd = min.add(f.reduceAdd, path);\n\t\tf.reduceRemove = min.remove(f.reduceRemove, path);\n\t\tf.reduceInitial = min.initial(f.reduceInitial, path);\n\t}\n\n\tif(p.max) {\n\t\tf.reduceAdd = max.add(f.reduceAdd, path);\n\t\tf.reduceRemove = max.remove(f.reduceRemove, path);\n\t\tf.reduceInitial = max.initial(f.reduceInitial, path);\n\t}\n\n\t// Maintain the values count array.\n\tif(p.exceptionAccessor) {\n\t\tf.reduceAdd = value_count.add(p.exceptionAccessor, f.reduceAdd, path);\n\t\tf.reduceRemove = value_count.remove(p.exceptionAccessor, f.reduceRemove, path);\n\t\tf.reduceInitial = value_count.initial(f.reduceInitial, path);\n\t}\n\n\t// Histogram\n\tif(p.histogramValue && p.histogramThresholds) {\n\t\tf.reduceAdd = histogram.add(p.histogramValue, f.reduceAdd, path);\n\t\tf.reduceRemove = histogram.remove(p.histogramValue, f.reduceRemove, path);\n\t\tf.reduceInitial = histogram.initial(p.histogramThresholds ,f.reduceInitial, path);\n\t}\n\n\t// Sum of Squares\n\tif(p.sumOfSquares) {\n\t\tf.reduceAdd = sum_of_sq.add(p.sumOfSquares, f.reduceAdd, path);\n\t\tf.reduceRemove = sum_of_sq.remove(p.sumOfSquares, f.reduceRemove, path);\n\t\tf.reduceInitial = sum_of_sq.initial(f.reduceInitial, path);\n\t}\n\n\t// Standard deviation\n\tif(p.std) {\n\t\tif(!p.sumOfSquares || !p.sum) {\n\t\t\tconsole.error(\"You must set .sumOfSq(accessor) and define a .sum(accessor) to use .std(true). Or use .std(accessor).\");\n\t\t} else {\n\t\t\tf.reduceAdd = std.add(f.reduceAdd, path);\n\t\t\tf.reduceRemove = std.remove(f.reduceRemove, path);\n\t\t\tf.reduceInitial = std.initial(f.reduceInitial, path);\n\t\t}\n\t}\n\n\t// Custom reducer defined by 3 functions : add, remove, initial\n\tif (p.custom) {\n\t\tf.reduceAdd = custom.add(f.reduceAdd, path, p.custom.add);\n\t\tf.reduceRemove = custom.remove(f.reduceRemove, path, p.custom.remove);\n\t\tf.reduceInitial = custom.initial(f.reduceInitial, path, p.custom.initial);\n\t}\n\n\t// Nesting\n\tif(p.nestKeys) {\n\t\tf.reduceAdd = nest.add(p.nestKeys, f.reduceAdd, path);\n\t\tf.reduceRemove = nest.remove(p.nestKeys, f.reduceRemove, path);\n\t\tf.reduceInitial = nest.initial(f.reduceInitial, path);\n\t}\n\n\t// Alias functions\n\tif(p.aliasKeys) {\n\t\tf.reduceInitial = alias.initial(f.reduceInitial, path, p.aliasKeys);\n\t}\n\n\t// Alias properties - this is less efficient than alias functions\n\tif(p.aliasPropKeys) {\n\t\tf.reduceAdd = alias_prop.add(p.aliasPropKeys, f.reduceAdd, path);\n\t\t// This isn't a typo. The function is the same for add/remove.\n\t\tf.reduceRemove = alias_prop.add(p.aliasPropKeys, f.reduceRemove, path);\n\t}\n\n\t// Filters determine if our built-up priors should run, or if it should skip\n\t// back to the filters given at the beginning of this build function.\n\tif (p.filter) {\n\t\tf.reduceAdd = filter.add(p.filter, f.reduceAdd, origF.reduceAdd, path);\n\t\tf.reduceRemove = filter.remove(p.filter, f.reduceRemove, origF.reduceRemove, path);\n\t}\n\n\t// Values go last.\n\tif(p.values) {\n\t\tObject.getOwnPropertyNames(p.values).forEach(function(n) {\n\t\t\t// Set up the path on each group.\n\t\t\tvar setupPath = function(prior) {\n\t\t\t\treturn function (p) {\n\t\t\t\t\tp = prior(p);\n\t\t\t\t\tpath(p)[n] = {};\n\t\t\t\t\treturn p;\n\t\t\t\t};\n\t\t\t};\n\t\t\tf.reduceInitial = setupPath(f.reduceInitial);\n\t\t\tbuild_function(p.values[n].parameters, f, function (p) { return p[n]; });\n\t\t});\n\t}\n}\n\nvar build = {\n\tbuild: build_function\n};\n\nexport default build;\n","import parameters from './parameters.js';\n\nfunction assign(target) {\n\tif (target == null) {\n\t\tthrow new TypeError('Cannot convert undefined or null to object');\n\t}\n\n\tvar output = Object(target);\n\tfor (var index = 1; index < arguments.length; ++index) {\n\t\tvar source = arguments[index];\n\t\tif (source != null) {\n\t\t\tfor (var nextKey in source) {\n\t\t\t\tif(source.hasOwnProperty(nextKey)) {\n\t\t\t\t\toutput[nextKey] = source[nextKey];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn output;\n}\n\nfunction accessor_build(obj, p) {\n\t// obj.order = function(value) {\n\t// \tif (!arguments.length) return p.order;\n\t// \tp.order = value;\n\t// \treturn obj;\n\t// };\n\n\t// Converts a string to an accessor function\n\tfunction accessorify(v) {\n\t\tif( typeof v === 'string' ) {\n\t\t\t// Rewrite to a function\n\t\t\tvar tempValue = v;\n\t\t\tvar func = function (d) { return d[tempValue]; }\n\t\t\treturn func;\n\t\t} else {\n\t\t\treturn v;\n\t\t}\n\t}\n\n\t// Converts a string to an accessor function\n\tfunction accessorifyNumeric(v) {\n\t\tif( typeof v === 'string' ) {\n\t\t\t// Rewrite to a function\n\t\t\tvar tempValue = v;\n\t\t\tvar func = function (d) { return +d[tempValue]; }\n\t\t\treturn func;\n\t\t} else {\n\t\t\treturn v;\n\t\t}\n\t}\n\n\tobj.fromObject = function(value) {\n\t\tif(!arguments.length) return p;\n\t\tassign(p, value);\n\t\treturn obj;\n\t};\n\n\tobj.toObject = function() {\n\t\treturn p;\n\t};\n\n\tobj.count = function(value, propName) {\n\t\tif (!arguments.length) return p.count;\n    if (!propName) {\n      propName = 'count';\n    }\n\t\tp.count = propName;\n\t\treturn obj;\n\t};\n\n\tobj.sum = function(value) {\n\t\tif (!arguments.length) return p.sum;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tp.sum = value;\n\t\treturn obj;\n\t};\n\n\tobj.avg = function(value) {\n\t\tif (!arguments.length) return p.avg;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\t// We can take an accessor function, a boolean, or a string\n\t\tif( typeof value === 'function' ) {\n\t\t\tif(p.sum && p.sum !== value) console.warn('SUM aggregation is being overwritten by AVG aggregation');\n\t\t\tp.sum = value;\n\t\t\tp.avg = true;\n\t\t\tp.count = 'count';\n\t\t} else {\n\t\t\tp.avg = value;\n\t\t}\n\t\treturn obj;\n\t};\n\n\tobj.exception = function(value) {\n\t\tif (!arguments.length) return p.exceptionAccessor;\n\n\t\tvalue = accessorify(value);\n\n\t\tp.exceptionAccessor = value;\n\t\treturn obj;\n\t};\n\n\tobj.filter = function(value) {\n\t\tif (!arguments.length) return p.filter;\n\t\tp.filter = value;\n\t\treturn obj;\n\t};\n\n\tobj.valueList = function(value) {\n\t\tif (!arguments.length) return p.valueList;\n\n\t\tvalue = accessorify(value);\n\n\t\tp.valueList = value;\n\t\treturn obj;\n\t};\n\n\tobj.median = function(value) {\n\t\tif (!arguments.length) return p.median;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tif(typeof value === 'function') {\n\t\t\tif(p.valueList && p.valueList !== value) console.warn('VALUELIST accessor is being overwritten by median aggregation');\n\t\t\tp.valueList = value;\n\t\t}\n\t\tp.median = value;\n\t\treturn obj;\n\t};\n\n\tobj.min = function(value) {\n\t\tif (!arguments.length) return p.min;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tif(typeof value === 'function') {\n\t\t\tif(p.valueList && p.valueList !== value) console.warn('VALUELIST accessor is being overwritten by min aggregation');\n\t\t\tp.valueList = value;\n\t\t}\n\t\tp.min = value;\n\t\treturn obj;\n\t};\n\n\tobj.max = function(value) {\n\t\tif (!arguments.length) return p.max;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tif(typeof value === 'function') {\n\t\t\tif(p.valueList && p.valueList !== value) console.warn('VALUELIST accessor is being overwritten by max aggregation');\n\t\t\tp.valueList = value;\n\t\t}\n\t\tp.max = value;\n\t\treturn obj;\n\t};\n\n\tobj.exceptionCount = function(value) {\n\t\tif (!arguments.length) return p.exceptionCount;\n\n\t\tvalue = accessorify(value);\n\n\t\tif( typeof value === 'function' ) {\n\t\t\tif(p.exceptionAccessor && p.exceptionAccessor !== value) console.warn('EXCEPTION accessor is being overwritten by exception count aggregation');\n\t\t\tp.exceptionAccessor = value;\n\t\t\tp.exceptionCount = true;\n\t\t} else {\n\t\t\tp.exceptionCount = value;\n\t\t}\n\t\treturn obj;\n\t};\n\n\tobj.exceptionSum = function(value) {\n\t\tif (!arguments.length) return p.exceptionSum;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tp.exceptionSum = value;\n\t\treturn obj;\n\t};\n\n\tobj.histogramValue = function(value) {\n\t\tif (!arguments.length) return p.histogramValue;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tp.histogramValue = value;\n\t\treturn obj;\n\t};\n\n\tobj.histogramBins = function(value) {\n\t\tif (!arguments.length) return p.histogramThresholds;\n\t\tp.histogramThresholds = value;\n\t\treturn obj;\n\t};\n\n\tobj.std = function(value) {\n\t\tif (!arguments.length) return p.std;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tif(typeof(value) === 'function') {\n\t\t\tp.sumOfSquares = value;\n\t\t\tp.sum = value;\n\t\t\tp.count = 'count';\n\t\t\tp.std = true;\n\t\t} else {\n\t\t\tp.std = value;\n\t\t}\n\t\treturn obj;\n\t};\n\n\tobj.sumOfSq = function(value) {\n\t\tif (!arguments.length) return p.sumOfSquares;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tp.sumOfSquares = value;\n\t\treturn obj;\n\t};\n\n\tobj.value = function(value, accessor) {\n\t\tif (!arguments.length || typeof value !== 'string' ) {\n\t\t\tconsole.error(\"'value' requires a string argument.\");\n\t\t} else {\n\t\t\tif(!p.values) p.values = {};\n\t\t\tp.values[value] = {};\n\t\t\tp.values[value].parameters = parameters();\n\t\t\taccessor_build(p.values[value], p.values[value].parameters);\n\t\t\tif(accessor) p.values[value].accessor = accessor;\n\t\t\treturn p.values[value];\n\t\t}\n\t};\n\n\tobj.nest = function(keyAccessorArray) {\n\t\tif(!arguments.length) return p.nestKeys;\n\n\t\tkeyAccessorArray.map(accessorify);\n\n\t\tp.nestKeys = keyAccessorArray;\n\t\treturn obj;\n\t};\n\n\tobj.alias = function(propAccessorObj) {\n\t\tif(!arguments.length) return p.aliasKeys;\n\t\tp.aliasKeys = propAccessorObj;\n\t\treturn obj;\n\t};\n\n\tobj.aliasProp = function(propAccessorObj) {\n\t\tif(!arguments.length) return p.aliasPropKeys;\n\t\tp.aliasPropKeys = propAccessorObj;\n\t\treturn obj;\n\t};\n\n\tobj.groupAll = function(groupTest) {\n\t\tif(!arguments.length) return p.groupAll;\n\t\tp.groupAll = groupTest;\n\t\treturn obj;\n\t};\n\n\tobj.dataList = function(value) {\n\t\tif (!arguments.length) return p.dataList;\n\t\tp.dataList = value;\n\t\treturn obj;\n\t};\n\n\tobj.custom = function(addRemoveInitialObj) {\n\t\tif (!arguments.length) return p.custom;\n\t\tp.custom = addRemoveInitialObj;\n\t\treturn obj;\n\t};\n\n}\n\nvar accessors = {\n\tbuild: accessor_build\n};\n\nexport default accessors;\n","var parameters = function() {\n\treturn {\n\t\torder: false,\n\t\tavg: false,\n\t\tcount: false,\n\t\tsum: false,\n\t\texceptionAccessor: false,\n\t\texceptionCount: false,\n\t\texceptionSum: false,\n\t\tfilter: false,\n\t\tvalueList: false,\n\t\tmedian: false,\n\t\thistogramValue: false,\n\t\tmin: false,\n\t\tmax: false,\n\t\thistogramThresholds: false,\n\t\tstd: false,\n\t\tsumOfSquares: false,\n\t\tvalues: false,\n\t\tnestKeys: false,\n\t\taliasKeys: false,\n\t\taliasPropKeys: false,\n\t\tgroupAll: false,\n\t\tdataList: false,\n\t\tcustom: false\n\t};\n};\n\nexport default parameters;\n","var pluck = function(n){\n    return function(d){\n        return d[n];\n    };\n};\n\n// supported operators are sum, avg, and count\nconst _grouper = function(path, prior){\n    if(!path) path = function(d){return d;};\n    return function(p, v){\n        if(prior) prior(p, v);\n        var x = path(p), y = path(v);\n        if(typeof y.count !== 'undefined') x.count += y.count;\n        if(typeof y.sum !== 'undefined') x.sum += y.sum;\n        if(typeof y.avg !== 'undefined') x.avg = x.sum/x.count;\n        return p;\n    };\n};\n\nconst cap = function (prior, f, p) {\n    var obj = f.reduceInitial();\n    // we want to support values so we'll need to know what those are\n    var values = p.values ? Object.keys(p.values) : [];\n    var _othersGrouper = _grouper();\n    if (values.length) {\n        for (var i = 0; i < values.length; ++i) {\n            _othersGrouper = _grouper(pluck(values[i]), _othersGrouper);\n        }\n    }\n    return function (cap, othersName) {\n        if (!arguments.length) return prior();\n        if( cap === Infinity || !cap ) return prior();\n        var all = prior();\n        var slice_idx = cap-1;\n        if(all.length <= cap) return all;\n        var data = all.slice(0, slice_idx);\n        var others = {key: othersName || 'Others'};\n        others.value = f.reduceInitial();\n        for (var i = slice_idx; i < all.length; ++i) {\n            _othersGrouper(others.value, all[i].value);\n        }\n        data.push(others);\n        return data;\n    };\n};\n\nexport default cap;\n","var pluck_n = function (n) {\n    if (typeof n === 'function') {\n        return n;\n    }\n    if (~n.indexOf('.')) {\n        var split = n.split('.');\n        return function (d) {\n            return split.reduce(function (p, v) {\n                return p[v];\n            }, d);\n        };\n    }\n    return function (d) {\n        return d[n];\n    };\n};\n\nfunction ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nvar comparer = function (accessor, ordering) {\n    return function (a, b) {\n        return ordering(accessor(a), accessor(b));\n    };\n};\n\nexport default function (prior) {\n    return function (value, order) {\n        if (arguments.length === 1) {\n            order = ascending;\n        }\n        return prior().sort(comparer(pluck_n(value), order));\n    };\n}\n","import build from './build.js';\nimport accessors from './accessors.js';\nimport params from './parameters.js';\nimport postprocess from './postprocess';\nimport postprocessors from './postprocessors';\nimport crossfilter from 'crossfilter2';\n\nfunction reductio() {\n\tvar parameters = params();\n\n\tvar funcs = {};\n\n\tfunction my(group) {\n\t\t// Start fresh each time.\n\t\tfuncs = {\n\t\t\treduceAdd: function(p) { return p; },\n\t\t\treduceRemove: function(p) { return p; },\n\t\t\treduceInitial: function () { return {}; },\n\t\t};\n\n\t\tbuild.build(parameters, funcs);\n\n\t\t// If we're doing groupAll\n\t\tif(parameters.groupAll) {\n\t\t\tif(group.top) {\n\t\t\t\tconsole.warn(\"'groupAll' is defined but attempting to run on a standard dimension.group(). Must run on dimension.groupAll().\");\n\t\t\t} else {\n\t\t\t\tvar bisect = crossfilter.bisect.by(function(d) { return d.key; }).left;\n\t\t\t\tvar i, j;\n\t\t\t\tvar keys;\n        var keysLength;\n        var k; // Key\n\t\t\t\tgroup.reduce(\n\t\t\t\t\tfunction(p, v, nf) {\n\t\t\t\t\t\tkeys = parameters.groupAll(v);\n            keysLength = keys.length;\n            for(j=0;j<keysLength;j++) {\n              k = keys[j];\n              i = bisect(p, k, 0, p.length);\n\t\t\t\t\t\t\tif(!p[i] || p[i].key !== k) {\n\t\t\t\t\t\t\t\t// If the group doesn't yet exist, create it first.\n\t\t\t\t\t\t\t\tp.splice(i, 0, { key: k, value: funcs.reduceInitial() });\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Then pass the record and the group value to the reducers\n\t\t\t\t\t\t\tfuncs.reduceAdd(p[i].value, v, nf);\n            }\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t},\n\t\t\t\t\tfunction(p, v, nf) {\n\t\t\t\t\t\tkeys = parameters.groupAll(v);\n            keysLength = keys.length;\n            for(j=0;j<keysLength;j++) {\n              i = bisect(p, keys[j], 0, p.length);\n\t\t\t\t\t\t\t// The group should exist or we're in trouble!\n\t\t\t\t\t\t\t// Then pass the record and the group value to the reducers\n\t\t\t\t\t\t\tfuncs.reduceRemove(p[i].value, v, nf);\n            }\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t},\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tif(!group.all) {\n\t\t\t\t\t// Add an 'all' method for compatibility with standard Crossfilter groups.\n\t\t\t\t\tgroup.all = function() { return this.value(); };\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgroup.reduce(funcs.reduceAdd, funcs.reduceRemove, funcs.reduceInitial);\n\t\t}\n\n\t\tpostprocessed(group, parameters, funcs);\n\n\t\treturn group;\n\t}\n\n\taccessors.build(my, parameters);\n\n\treturn my;\n}\n\npostprocessors(reductio);\nconst postprocessed = postprocess(reductio);\n\nexport default reductio;\n","import cap from './cap';\nimport sortBy from './sortBy';\n\nexport default function(reductio){\n    reductio.postprocessors = {};\n    reductio.registerPostProcessor = function(name, func){\n        reductio.postprocessors[name] = func;\n    };\n\n    reductio.registerPostProcessor('cap', cap);\n    reductio.registerPostProcessor('sortBy', sortBy);\n}\n","function postProcess(reductio) {\n    return function (group, p, f) {\n        group.post = function(){\n            var postprocess = function () {\n                return postprocess.all();\n            };\n            postprocess.all = function () {\n                return group.all();\n            };\n            var postprocessors = reductio.postprocessors;\n            Object.keys(postprocessors).forEach(function (name) {\n                postprocess[name] = function () {\n                    var _all = postprocess.all;\n                    var args = [].slice.call(arguments);\n                    postprocess.all = function () {\n                        return postprocessors[name](_all, f, p).apply(null, args);\n                    };\n                    return postprocess;\n                };\n            });\n            return postprocess;\n        };\n    };\n}\n\nexport default postProcess;\n","export default {\n  shorthandLabels: {\n    $count: 'count',\n    $sum: 'sum',\n    $avg: 'avg',\n    $min: 'min',\n    $max: 'max',\n    $med: 'med',\n    $sumSq: 'sumSq',\n    $std: 'std',\n  },\n  aggregators: {\n    $count: $count,\n    $sum: $sum,\n    $avg: $avg,\n    $min: $min,\n    $max: $max,\n    $med: $med,\n    $sumSq: $sumSq,\n    $std: $std,\n    $valueList: $valueList,\n    $dataList: $dataList,\n  },\n}\n\n// Aggregators\n\nfunction $count(reducer/* , value */) {\n  return reducer.count(true)\n}\n\nfunction $sum(reducer, value) {\n  return reducer.sum(value)\n}\n\nfunction $avg(reducer, value) {\n  return reducer.avg(value)\n}\n\nfunction $min(reducer, value) {\n  return reducer.min(value)\n}\n\nfunction $max(reducer, value) {\n  return reducer.max(value)\n}\n\nfunction $med(reducer, value) {\n  return reducer.median(value)\n}\n\nfunction $sumSq(reducer, value) {\n  return reducer.sumOfSq(value)\n}\n\nfunction $std(reducer, value) {\n  return reducer.std(value)\n}\n\nfunction $valueList(reducer, value) {\n  return reducer.valueList(value)\n}\n\nfunction $dataList(reducer/* , value */) {\n  return reducer.dataList(true)\n}\n\n// TODO histograms\n// TODO exceptions\n","import _ from './lodash'\nimport aggregation from './aggregation'\n\nexport default function (/* service */) {\n  return {\n    post: post,\n    sortByKey: sortByKey,\n    limit: limit,\n    squash: squash,\n    change: change,\n    changeMap: changeMap,\n  }\n\n  function post(query, parent, cb) {\n    query.data = cloneIfLocked(parent)\n    return Promise.resolve(cb(query, parent))\n  }\n\n  function sortByKey(query, parent, desc) {\n    query.data = cloneIfLocked(parent)\n    query.data = _.sortBy(query.data, function (d) {\n      return d.key\n    })\n    if (desc) {\n      query.data.reverse()\n    }\n  }\n\n  // Limit results to n, or from start to end\n  function limit(query, parent, start, end) {\n    query.data = cloneIfLocked(parent)\n    if (_.isUndefined(end)) {\n      end = start || 0\n      start = 0\n    } else {\n      start = start || 0\n      end = end || query.data.length\n    }\n    query.data = query.data.splice(start, end - start)\n  }\n\n  // Squash results to n, or from start to end\n  function squash(query, parent, start, end, aggObj, label) {\n    query.data = cloneIfLocked(parent)\n    start = start || 0\n    end = end || query.data.length\n    var toSquash = query.data.splice(start, end - start)\n    var squashed = {\n      key: label || 'Other',\n      value: {},\n    }\n    _.recurseObject(aggObj, function (val, key, path) {\n      var items = []\n      _.forEach(toSquash, function (record) {\n        items.push(_.get(record.value, path))\n      })\n      _.set(squashed.value, path, aggregation.aggregators[val](items))\n    })\n    query.data.splice(start, 0, squashed)\n  }\n\n  function change(query, parent, start, end, aggObj) {\n    query.data = cloneIfLocked(parent)\n    start = start || 0\n    end = end || query.data.length\n    var obj = {\n      key: [query.data[start].key, query.data[end].key],\n      value: {},\n    }\n    _.recurseObject(aggObj, function (val, key, path) {\n      var changePath = _.clone(path)\n      changePath.pop()\n      changePath.push(key + 'Change')\n      _.set(obj.value, changePath, _.get(query.data[end].value, path) - _.get(query.data[start].value, path))\n    })\n    query.data = obj\n  }\n\n  function changeMap(query, parent, aggObj, defaultNull) {\n    defaultNull = _.isUndefined(defaultNull) ? 0 : defaultNull\n    query.data = cloneIfLocked(parent)\n    _.recurseObject(aggObj, function (val, key, path) {\n      var changePath = _.clone(path)\n      var fromStartPath = _.clone(path)\n      var fromEndPath = _.clone(path)\n\n      changePath.pop()\n      fromStartPath.pop()\n      fromEndPath.pop()\n\n      changePath.push(key + 'Change')\n      fromStartPath.push(key + 'ChangeFromStart')\n      fromEndPath.push(key + 'ChangeFromEnd')\n\n      var start = _.get(query.data[0].value, path, defaultNull)\n      var end = _.get(query.data[query.data.length - 1].value, path, defaultNull)\n\n      _.forEach(query.data, function (record, i) {\n        var previous = query.data[i - 1] || query.data[0]\n        _.set(query.data[i].value, changePath, _.get(record.value, path, defaultNull) - (previous ? _.get(previous.value, path, defaultNull) : defaultNull))\n        _.set(query.data[i].value, fromStartPath, _.get(record.value, path, defaultNull) - start)\n        _.set(query.data[i].value, fromEndPath, _.get(record.value, path, defaultNull) - end)\n      })\n    })\n  }\n}\n\nfunction cloneIfLocked(parent) {\n  return parent.locked ? _.clone(parent.data) : parent.data\n}\n","import _ from './lodash'\nimport _reductiofy from './reductiofy'\nimport _filters from './filters'\nimport _postAggregation from './postAggregation'\n\nexport default function (service) {\n  var reductiofy = _reductiofy(service)\n  var filters = _filters(service)\n  var postAggregation = _postAggregation(service)\n\n  var postAggregationMethods = _.keys(postAggregation)\n\n  return function doQuery(queryObj) {\n    var queryHash = JSON.stringify(queryObj)\n\n    // Attempt to reuse an exact copy of this query that is present elsewhere\n    for (var i = 0; i < service.columns.length; i++) {\n      for (var j = 0; j < service.columns[i].queries.length; j++) {\n        if (service.columns[i].queries[j].hash === queryHash) {\n          return new Promise(function (resolve, reject) { // eslint-disable-line no-loop-func\n            try {\n              resolve(service.columns[i].queries[j])\n            } catch (err) {\n              reject(err)\n            }\n          })\n        }\n      }\n    }\n\n    var query = {\n      // Original query passed in to query method\n      original: queryObj,\n      hash: queryHash,\n    }\n\n    // Default queryObj\n    if (_.isUndefined(query.original)) {\n      query.original = {}\n    }\n    // Default select\n    if (_.isUndefined(query.original.select)) {\n      query.original.select = {\n        $count: true,\n      }\n    }\n    // Default to groupAll\n    query.original.groupBy = query.original.groupBy || true\n\n    // Attach the query api to the query object\n    query = newQueryObj(query)\n\n    return createColumn(query)\n      .then(makeCrossfilterGroup)\n      .then(buildRequiredColumns)\n      .then(setupDataListeners)\n      .then(applyQuery)\n\n    function createColumn(query) {\n      // Ensure column is created\n      return service.column({\n        key: query.original.groupBy,\n        type: _.isUndefined(query.type) ? null : query.type,\n        array: Boolean(query.array),\n      })\n        .then(function () {\n        // Attach the column to the query\n          var column = service.column.find(query.original.groupBy)\n          query.column = column\n          column.queries.push(query)\n          column.removeListeners.push(function () {\n            return query.clear()\n          })\n          return query\n        })\n    }\n\n    function makeCrossfilterGroup(query) {\n      // Create the grouping on the columns dimension\n      // Using Promise Resolve allows support for crossfilter async\n      // TODO check if query already exists, and use the same base query // if possible\n      return Promise.resolve(query.column.dimension.group())\n        .then(function (g) {\n          query.group = g\n          return query\n        })\n    }\n\n    function buildRequiredColumns(query) {\n      var requiredColumns = filters.scanForDynamicFilters(query.original)\n      // We need to scan the group for any filters that would require\n      // the group to be rebuilt when data is added or removed in any way.\n      if (requiredColumns.length) {\n        return Promise.all(_.map(requiredColumns, function (columnKey) {\n          return service.column({\n            key: columnKey,\n            dynamicReference: query.group,\n          })\n        }))\n          .then(function () {\n            return query\n          })\n      }\n      return query\n    }\n\n    function setupDataListeners(query) {\n      // Here, we create a listener to recreate and apply the reducer to\n      // the group anytime underlying data changes\n      var stopDataListen = service.onDataChange(function () {\n        return applyQuery(query)\n      })\n      query.removeListeners.push(stopDataListen)\n\n      // This is a similar listener for filtering which will (if needed)\n      // run any post aggregations on the data after each filter action\n      var stopFilterListen = service.onFilter(function () {\n        return postAggregate(query)\n      })\n      query.removeListeners.push(stopFilterListen)\n\n      return query\n    }\n\n    function applyQuery(query) {\n      return buildReducer(query)\n        .then(applyReducer)\n        .then(attachData)\n        .then(postAggregate)\n    }\n\n    function buildReducer(query) {\n      return reductiofy(query.original)\n        .then(function (reducer) {\n          query.reducer = reducer\n          return query\n        })\n    }\n\n    function applyReducer(query) {\n      return Promise.resolve(query.reducer(query.group))\n        .then(function () {\n          return query\n        })\n    }\n\n    function attachData(query) {\n      return Promise.resolve(query.group.all())\n        .then(function (data) {\n          query.data = data\n          return query\n        })\n    }\n\n    function postAggregate(query) {\n      if (query.postAggregations.length > 1) {\n        // If the query is used by 2+ post aggregations, we need to lock\n        // it against getting mutated by the post-aggregations\n        query.locked = true\n      }\n      return Promise.all(_.map(query.postAggregations, function (post) {\n        return post()\n      }))\n        .then(function () {\n          return query\n        })\n    }\n\n    function newQueryObj(q, parent) {\n      var locked = false\n      if (!parent) {\n        parent = q\n        q = {}\n        locked = true\n      }\n\n      // Assign the regular query properties\n      Object.assign(q, {\n        // The Universe for continuous promise chaining\n        universe: service,\n        // Crossfilter instance\n        crossfilter: service.cf,\n\n        // parent Information\n        parent: parent,\n        column: parent.column,\n        dimension: parent.dimension,\n        group: parent.group,\n        reducer: parent.reducer,\n        original: parent.original,\n        hash: parent.hash,\n\n        // It's own removeListeners\n        removeListeners: [],\n\n        // It's own postAggregations\n        postAggregations: [],\n\n        // Data method\n        locked: locked,\n        lock: lock,\n        unlock: unlock,\n        // Disposal method\n        clear: clearQuery,\n      })\n\n      _.forEach(postAggregationMethods, function (method) {\n        q[method] = postAggregateMethodWrap(postAggregation[method])\n      })\n\n      return q\n\n      function lock(set) {\n        if (!_.isUndefined(set)) {\n          q.locked = Boolean(set)\n          return\n        }\n        q.locked = true\n      }\n\n      function unlock() {\n        q.locked = false\n      }\n\n      function clearQuery() {\n        _.forEach(q.removeListeners, function (l) {\n          l()\n        })\n        return new Promise(function (resolve, reject) {\n          try {\n            resolve(q.group.dispose())\n          } catch (err) {\n            reject(err)\n          }\n        })\n          .then(function () {\n            q.column.queries.splice(q.column.queries.indexOf(q), 1)\n            // Automatically recycle the column if there are no queries active on it\n            if (!q.column.queries.length) {\n              return service.clear(q.column.key)\n            }\n          })\n          .then(function () {\n            return service\n          })\n      }\n\n      function postAggregateMethodWrap(postMethod) {\n        return function () {\n          var args = Array.prototype.slice.call(arguments)\n          var sub = {}\n          newQueryObj(sub, q)\n          args.unshift(sub, q)\n\n          q.postAggregations.push(function () {\n            Promise.resolve(postMethod.apply(null, args))\n              .then(postAggregateChildren)\n          })\n\n          return Promise.resolve(postMethod.apply(null, args))\n            .then(postAggregateChildren)\n\n          function postAggregateChildren() {\n            return postAggregate(sub)\n              .then(function () {\n                return sub\n              })\n          }\n        }\n      }\n    }\n  }\n}\n","import reductio from 'reductio'\nimport _ from './lodash'\nimport rAggregators from './reductioAggregators'\nimport _filters from './filters'\n\nimport aggregation from './aggregation'\n\nexport default function (service) {\n  var filters = _filters(service)\n\n  return function reductiofy(query) {\n    var reducer = reductio()\n    // var groupBy = query.groupBy // groupBy is defined but never used\n    aggregateOrNest(reducer, query.select)\n\n    if (query.filter) {\n      var filterFunction = filters.makeFunction(query.filter)\n      if (filterFunction) {\n        reducer.filter(filterFunction)\n      }\n    }\n\n    return Promise.resolve(reducer)\n\n    // This function recursively find the first level of reductio methods in\n    // each object and adds that reduction method to reductio\n    function aggregateOrNest(reducer, selects) {\n      // Sort so nested values are calculated last by reductio's .value method\n      var sortedSelectKeyValue = _.sortBy(\n        _.map(selects, function (val, key) {\n          return {\n            key: key,\n            value: val,\n          }\n        }),\n        function (s) {\n          if (rAggregators.aggregators[s.key]) {\n            return 0\n          }\n          return 1\n        })\n\n      // dive into each key/value\n      return _.forEach(sortedSelectKeyValue, function (s) {\n        // Found a Reductio Aggregation\n        if (rAggregators.aggregators[s.key]) {\n          // Build the valueAccessorFunction\n          var accessor = aggregation.makeValueAccessor(s.value)\n          // Add the reducer with the ValueAccessorFunction to the reducer\n          reducer = rAggregators.aggregators[s.key](reducer, accessor)\n          return\n        }\n\n        // Found a top level key value that is not an aggregation or a\n        // nested object. This is unacceptable.\n        if (!_.isObject(s.value)) {\n          console.error('Nested selects must be an object', s.key)\n          return\n        }\n\n        // It's another nested object, so just repeat this process on it\n        aggregateOrNest(reducer.value(s.key), s.value)\n      })\n    }\n  }\n}\n","import _ from './lodash'\n\nexport default function(service) {\n  return function clear(def) {\n    // Clear a single or multiple column definitions\n    if (def) {\n      def = _.isArray(def) ? def : [def]\n    }\n\n    if (!def) {\n      // Clear all of the column defenitions\n      return Promise.all(\n        _.map(service.columns, disposeColumn)\n      ).then(function() {\n        service.columns = []\n        return service\n      })\n    }\n\n    return Promise.all(\n      _.map(def, function(d) {\n        if (_.isObject(d)) {\n          d = d.key\n        }\n        // Clear the column\n        var column = _.remove(service.columns, function(c) {\n          if (_.isArray(d)) {\n            return !_.xor(c.key, d).length\n          }\n          if (c.key === d) {\n            if (c.dynamicReference) {\n              return false\n            }\n            return true\n          }\n        })[0]\n\n        if (!column) {\n          // console.info('Attempted to clear a column that is required for another query!', c)\n          return\n        }\n\n        disposeColumn(column)\n      })\n    ).then(function() {\n      return service\n    })\n\n    function disposeColumn(column) {\n      var disposalActions = []\n      // Dispose the dimension\n      if (column.removeListeners) {\n        disposalActions = _.map(column.removeListeners, function(listener) {\n          return Promise.resolve(listener())\n        })\n      }\n      var filterKey = column.key\n      if (column.complex === 'array') {\n        filterKey = JSON.stringify(column.key)\n      }\n      if (column.complex === 'function') {\n        filterKey = column.key.toString()\n      }\n      delete service.filters[filterKey]\n      if (column.dimension) {\n        disposalActions.push(Promise.resolve(column.dimension.dispose()))\n      }\n      return Promise.all(disposalActions)\n    }\n  }\n}\n","export default function (service) {\n  return function destroy() {\n    return service.clear()\n      .then(function () {\n        service.cf.dataListeners = []\n        service.cf.filterListeners = []\n        return Promise.resolve(service.cf.remove())\n      })\n      .then(function () {\n        return service\n      })\n  }\n}\n","import _filters from './filters'\nimport _crossfilter from './crossfilter'\nimport column from './column'\nimport query from './query'\nimport clear from './clear'\nimport destroy from './destroy'\n\nfunction universe(data, options) {\n  var service = {\n    options: Object.assign({}, options),\n    columns: [],\n    filters: {},\n    dataListeners: [],\n    filterListeners: [],\n  }\n\n  var cf = _crossfilter(service)\n  var filters = _filters(service)\n\n  data = cf.generateColumns(data)\n\n  return cf.build(data)\n    .then(function (data) {\n      service.cf = data\n      return Object.assign(service, {\n        add: cf.add,\n        remove: cf.remove,\n        column: column(service),\n        query: query(service),\n        filter: filters.filter,\n        filterAll: filters.filterAll,\n        applyFilters: filters.applyFilters,\n        clear: clear(service),\n        destroy: destroy(service),\n        onDataChange: onDataChange,\n        onFilter: onFilter,\n      })\n    })\n\n  function onDataChange(cb) {\n    service.dataListeners.push(cb)\n    return function () {\n      service.dataListeners.splice(service.dataListeners.indexOf(cb), 1)\n    }\n  }\n\n  function onFilter(cb) {\n    service.filterListeners.push(cb)\n    return function () {\n      service.filterListeners.splice(service.filterListeners.indexOf(cb), 1)\n    }\n  }\n}\n\nexport default universe","import crossfilter from 'crossfilter2'\nimport _ from './lodash'\n\nexport default function (service) {\n  return {\n    build: build,\n    generateColumns: generateColumns,\n    add: add,\n    remove: remove,\n  }\n\n  function build(c) {\n    if (_.isArray(c)) {\n      // This allows support for crossfilter async\n      return Promise.resolve(crossfilter(c))\n    }\n    if (!c || typeof c.dimension !== 'function') {\n      return Promise.reject(new Error('No Crossfilter data or instance found!'))\n    }\n    return Promise.resolve(c)\n  }\n\n  function generateColumns(data) {\n    if (!service.options.generatedColumns) {\n      return data\n    }\n    return _.map(data, function (d/* , i */) {\n      _.forEach(service.options.generatedColumns, function (val, key) {\n        d[key] = val(d)\n      })\n      return d\n    })\n  }\n\n  function add(data) {\n    data = generateColumns(data)\n    return new Promise(function (resolve, reject) {\n      try {\n        resolve(service.cf.add(data))\n      } catch (err) {\n        reject(err)\n      }\n    })\n      .then(function () {\n        return _.map(service.dataListeners, function (listener) {\n          return function () {\n            return listener({\n              added: data,\n            })\n          }\n        }).reduce(function(promise, data) {\n          return promise.then(data)\n        }, Promise.resolve(true))\n      })\n\n      .then(function() {\n        return Promise.all(_.map(service.filterListeners, function (listener) {\n          return listener()\n        }))      \n      })\n\n      .then(function () {\n        return service\n      })\n  }\n\n  function remove(predicate) {\n    return new Promise(function (resolve, reject) {\n      try {\n        resolve(service.cf.remove(predicate))\n      } catch (err) {\n        reject(err)\n      }\n    })\n    \n      .then(function() {\n        return Promise.all(_.map(service.filterListeners, function (listener) {\n          return listener()\n        }))      \n      })\n    \n      .then(function () {\n        return service\n      })\n  }\n}\n\n\n"],"names":["find","a","b","remove","filter","o","i","splice","isArray","isObject","isBoolean","d","isString","isNumber","isFunction","get","join","replace","split","reduce","obj","property","set","prop","value","length","e","shift","Object","assign","prototype","toString","call","map","m","key","hasOwnProperty","push","aa","keys","sortBy","sort","bb","forEach","isUndefined","pick","c","xor","unique","indexOf","clone","isEqual","x","y","replaceArray","al","bl","apply","Array","val","uniq","seen","Set","item","allow","has","add","flatten","flattened","current","j","arr","tmp","values","recurseObject","cb","_recurseObject","path","k","newPath","JSON","parse","stringify","$field","child","$and","$or","$not","$eq","$gt","$gte","$lt","$lte","$ne","$type","$in","$nin","$contains","$excludes","$size","aggregators","$sum","children","$avg","$max","Math","max","$min","min","$count","$first","$last","$get","$nth","$nthLast","n","$nthPct","round","$map","makeValueAccessor","isStringSyntax","convertAggregatorString","_","stack","makeSubAggregationFunction","extractKeyValOrArray","parseAggregatorParams","keyString","params","p1","p2","substring","aggregator","subStack","s","subAggregationFunction","console","error","keyVal","subObj","str","charAt","outerParens","hasComma","unwrapParensAndCommas","p","pr","test","trim","service","column","fil","isRange","getColumn","then","newFilters","filters","filterKey","complex","buildFilterObject","applyFilters","filterAll","fils","columns","col","dimension","ds","Promise","all","makeFunction","scanForDynamicFilters","query","walk","ref","findDataReferences","exists","resolve","reject","temporary","err","function","type","existing","toggleFilters","filterExact","filterRange","filterFunction","tryRemoval","v","dynamicReference","clear","filterListeners","listener","warn","isAggregation","subGetters","data","cf","expressions","getSub","dataRef","aggregatorObj","aggregation","concat","log","array8","arrayUntyped","array16","array32","arrayLengthen","arrayLengthenUntyped","arrayWiden","arrayWidenUntyped","array","width","Error","bitarray","subarrays","masks","Uint8Array","Uint16Array","Uint32Array","copy","constructor","lengthen","len","this","w","one","offset","dest","src","truncate","zero","zeroExcept","zeroExceptMask","mask","only","onlyExcept","onlyOffset","onlyOne","bisect","left","right","range","heap_by","f","heap","lo","hi","sift","t","h","identity","heapselect_by","xFilterHeap","by","queue","bisect_by","bisectRight","mid","index","deep","action","id","reg","crossfilter","removeData","groupAll","size","allFiltered","onChange","isElementFiltered","dataListeners","removeDataListeners","callbacks","newData","n0","n1","l","triggerOnChange","predicate","newIndex","removed","usePred","index1","index2","index3","index4","maskForDimensions","dimensions","ignore_dimensions","iterable","accessorPath","result","newValues","iterablesIndexCount","iterablesIndexFilterStatus","refilterFunction","filterValue","filterValuePresent","currentFilter","hasCurrentFilter","top","top_offset","hi0","toSkip","lo0","iterablesEmptyRows","bottom","bottom_offset","group","g","cr_null","order","orderNatural","dispose","accessor","sortRange","cr_range","A","B","refilter","xfilterFilter","indexListeners","dimensionGroups","unshift","preAdd","postAdd","newIterablesIndexCount","newIterablesIndexFilterStatus","i0","cr_index","unsortedIndex","sortMap","permute","bounds","lo1","hi1","old_n0","oldValues","oldIndex","oldIterablesIndexFilterStatus","i1","oldiiclength","xfilterArray","index5","reIndex","slice","oldDataIndex","filterIndexBounds","filterIndexFunction","added","valueIndexAdded","valueIndexRemoved","newAdded","newRemoved","undefined","indexLength","reduceCount","reduceSum","groups","groupIndex","select","reduceAdd","reduceRemove","reduceInitial","n0old","groupWidth","groupCapacity","capacity","update","reset","resetNeeded","g0","x0","x1","oldGroups","initial","k0","groupIncrement","updateMany","resetMany","updateOne","resetOne","oldK","seenGroups","filterOne","filterOffset","notFilter","xfilterReduce","cr_zero","valueOf","xfilterHeapselect","xfilterHeap","cr_identity","arguments","reduceValue","eventName","make","makeAccessor","accessorFunction","arrayString","Function","String","_dimension","columnFunc","def","makeColumn","findColumn","promise","queries","sample","getType","dim","filterCount","stopListeningForData","onDataChange","buildColumnKeys","removeListeners","changes","Infinity","rows","heapselect","prior","skip","nf","count","propName","sum","avg","median","half","floor","valueList","insertionsort_by","insertion","quicksort_by","insertionsort","xFilterInsertionsort","quicksort_sizeThreshold","quicksort","sixth","i5","i3","i2","i4","e1","e2","x2","e3","x3","e4","x4","e5","x5","pivot1","pivotValue1","pivot2","pivotValue2","less","great","pivotsEqual","ek","xk","greatValue","lessValue","q","value_count","curr","value_list","exception_count","exceptionCount","exception_sum","exceptionSum","histogram","bisectHisto","thresholds","dx","sum_of_sq","sumOfSq","std","sqrt","nest","keyAccessors","arrRef","newRef","alias","buildAliasFunction","alias_prop","data_list","dataList","custom","addFn","removeFn","initialFn","build","build_function","origF","exceptionAccessor","histogramValue","histogramThresholds","sumOfSquares","nestKeys","aliasKeys","aliasPropKeys","getOwnPropertyNames","parameters","target","TypeError","output","source","nextKey","accessors","accessor_build","accessorify","tempValue","accessorifyNumeric","fromObject","toObject","exception","histogramBins","keyAccessorArray","propAccessorObj","aliasProp","groupTest","addRemoveInitialObj","pluck","_grouper","cap","_othersGrouper","othersName","slice_idx","others","pluck_n","ascending","NaN","comparer","ordering","reductio","funcs","my","keysLength","postprocessed","postprocessors","registerPostProcessor","name","func","post","postprocess","_all","args","shorthandLabels","$med","$sumSq","$std","reducer","$valueList","$dataList","cloneIfLocked","parent","locked","reductiofy","_filters","aggregateOrNest","selects","sortedSelectKeyValue","rAggregators","_reductiofy","postAggregation","sortByKey","desc","reverse","limit","start","end","squash","aggObj","label","toSquash","squashed","items","record","change","changePath","pop","changeMap","defaultNull","fromStartPath","fromEndPath","previous","postAggregationMethods","queryObj","queryHash","hash","original","groupBy","Boolean","createColumn","newQueryObj","universe","postAggregations","lock","unlock","clearQuery","method","postAggregateMethodWrap","postMethod","sub","postAggregateChildren","postAggregate","requiredColumns","columnKey","stopDataListen","applyQuery","stopFilterListen","onFilter","buildReducer","applyReducer","attachData","disposeColumn","disposalActions","options","generateColumns","generatedColumns","_crossfilter","destroy"],"mappings":"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"}