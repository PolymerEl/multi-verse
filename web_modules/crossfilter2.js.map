{"version":3,"file":"crossfilter2.js","sources":["../node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/array.js","../node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/filter.js","../node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/identity.js","../node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/null.js","../node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/zero.js","../node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/heap.js","../node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/heapselect.js","../node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/bisect.js","../node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/permute.js","../node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/reduce.js","../node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/result.js","../node_modules/.pnpm/registry.npmjs.org/@ranfdev/deepobj/1.0.2/node_modules/@ranfdev/deepobj/dist/deepobj.m.js","../node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/index.js"],"sourcesContent":["let array8 = arrayUntyped,\n    array16 = arrayUntyped,\n    array32 = arrayUntyped,\n    arrayLengthen = arrayLengthenUntyped,\n    arrayWiden = arrayWidenUntyped;\nif (typeof Uint8Array !== \"undefined\") {\n  array8 = function(n) { return new Uint8Array(n); };\n  array16 = function(n) { return new Uint16Array(n); };\n  array32 = function(n) { return new Uint32Array(n); };\n\n  arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = array16(array.length); break;\n      case 32: copy = array32(array.length); break;\n      default: throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\n\n// An arbitrarily-wide array of bitmasks\nfunction bitarray(n) {\n  this.length = n;\n  this.subarrays = 1;\n  this.width = 8;\n  this.masks = {\n    0: 0\n  }\n\n  this[0] = array8(n);\n}\n\nbitarray.prototype.lengthen = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i] = arrayLengthen(this[i], n);\n  }\n  this.length = n;\n};\n\n// Reserve a new bit index in the array, returns {offset, one}\nbitarray.prototype.add = function() {\n  var m, w, one, i, len;\n\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    m = this.masks[i];\n    w = this.width - (32 * i);\n    // isolate the rightmost zero bit and return it as an unsigned int of 32 bits, if NaN or -1, return a 0 \n    one = (~m & (m + 1)) >>> 0;\n\n    if (w >= 32 && !one) {\n      continue;\n    }\n\n    if (w < 32 && (one & (1 << w))) {\n      // widen this subarray\n      this[i] = arrayWiden(this[i], w <<= 1);\n      this.width = 32 * i + w;\n    }\n\n    this.masks[i] |= one;\n\n    return {\n      offset: i,\n      one: one\n    };\n  }\n\n  // add a new subarray\n  this[this.subarrays] = array8(this.length);\n  this.masks[this.subarrays] = 1;\n  this.width += 8;\n  return {\n    offset: this.subarrays++,\n    one: 1\n  };\n};\n\n// Copy record from index src to index dest\nbitarray.prototype.copy = function(dest, src) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i][dest] = this[i][src];\n  }\n};\n\n// Truncate the array to the given length\nbitarray.prototype.truncate = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    for (var j = this.length - 1; j >= n; j--) {\n      this[i][j] = 0;\n    }\n  }\n  this.length = n;\n};\n\n// Checks that all bits for the given index are 0\nbitarray.prototype.zero = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for possibly one\nbitarray.prototype.zeroExcept = function(n, offset, zero) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (i === offset ? this[i][n] & zero : this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for the specified mask.\n// The mask should be an array of the same size as the filter subarrays width.\nbitarray.prototype.zeroExceptMask = function(n, mask) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] & mask[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks that only the specified bit is set for the given index\nbitarray.prototype.only = function(n, offset, one) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] != (i === offset ? one : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that only the specified bit is set for the given index except for possibly one other\nbitarray.prototype.onlyExcept = function(n, offset, zero, onlyOffset, onlyOne) {\n  var mask;\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    mask = this[i][n];\n    if (i === offset)\n      mask &= zero;\n    if (mask != (i === onlyOffset ? onlyOne : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport default {\n  array8: arrayUntyped,\n  array16: arrayUntyped,\n  array32: arrayUntyped,\n  arrayLengthen: arrayLengthenUntyped,\n  arrayWiden: arrayWidenUntyped,\n  bitarray: bitarray\n};\n","const filterExact = (bisect, value) => {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nconst filterRange = (bisect, range) => {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nconst filterAll = values => {\n  return [0, values.length];\n}\n\nexport default {\n  filterExact,\n  filterRange,\n  filterAll\n};\n","export default d => {\n  return d;\n};\n","export default () =>  {\n  return null;\n}\n","export default () => {\n  return 0;\n}\n","import identity from './identity';\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\n\nconst h = heap_by(identity);\nh.by = heap_by;\n\nexport default h;\n","import identity from './identity';\nimport xFilterHeap from './heap';\n\nfunction heapselect_by(f) {\n  var heap = xFilterHeap.by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\n\n\nconst h = heapselect_by(identity);\nh.by = heapselect_by; // assign the raw function to the export as well\n\nexport default h;\n","import identity from './identity';\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\n\nconst bisect = bisect_by(identity);\nbisect.by = bisect_by; // assign the raw function to the export as well\n\nexport default bisect;\n\n","export default (array, index, deep) => {\n  for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\n","const reduceIncrement = p => {\n  return p + 1;\n}\n\nconst reduceDecrement = p => {\n  return p - 1;\n}\n\nconst reduceAdd = f => {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nconst reduceSubtract = f => {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\n\nexport default {\n  reduceIncrement,\n  reduceDecrement,\n  reduceAdd,\n  reduceSubtract\n};\n","import deep from \"@ranfdev/deepobj\"\n// Note(cg): result was previsouly using lodash.result, not ESM compatible.\n \nconst get = (obj, prop) => {\n  const value = obj[prop];\n  return (typeof value === 'function') ? value.call(obj) : value;\n}\n\n/**\n * get value of object at a deep path.\n * if the resolved value is a function,\n * it's invoked with the `this` binding of \n * its parent object and its result is returned. \n *  \n * @param  {Object} obj  the object (e.g. { 'a': [{ 'b': { 'c1': 3, 'c2': 4} }], 'd': {e:1} }; )\n * @param  {String} path deep path (e.g. `d.e`` or `a[0].b.c1`. Dot notation (a.0.b)is also supported)\n * @return {Any}      the resolved value\n */\nconst reg = /\\[([\\w\\d]+)\\]/g;\nexport default (obj, path) => {\n  return deep(get, obj, path.replace(reg, '.$1'))\n}\n","export default function(t,e,i,n,r){for(r in n=(i=i.split(\".\")).splice(-1,1),i)e=e[i[r]]=e[i[r]]||{};return t(e,n)};\n//# sourceMappingURL=deepobj.m.js.map\n","import xfilterArray from './array';\nimport xfilterFilter from './filter';\nimport cr_identity from './identity';\nimport cr_null from './null';\nimport cr_zero from './zero';\nimport xfilterHeapselect from './heapselect';\nimport xfilterHeap from './heap';\nimport bisect from './bisect';\nimport permute from './permute';\nimport xfilterReduce from './reduce';\nimport result from './result';\n\n// constants\nvar REMOVED_INDEX = -1;\n\ncrossfilter.heap = xfilterHeap;\ncrossfilter.heapselect = xfilterHeapselect;\ncrossfilter.bisect = bisect;\ncrossfilter.permute = permute;\nexport default crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size,\n    all: all,\n    allFiltered: allFiltered,\n    onChange: onChange,\n    isElementFiltered: isElementFiltered\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      filters, // 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = [], // when data is removed\n      callbacks = [];\n\n  filters = new xfilterArray.bitarray(0);\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add…\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters.lengthen(n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n      triggerOnChange('dataAdded');\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters, or if a predicate function is passed,\n  // removes all records matching the predicate (ignoring filters).\n  function removeData(predicate) {\n    var // Mapping from old record indexes to new indexes (after records removed)\n        newIndex = new Array(n),\n        removed = [],\n        usePred = typeof predicate === 'function',\n        shouldRemove = function (i) {\n          return usePred ? predicate(data[i], i) : filters.zero(i)\n        };\n\n    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n      if ( shouldRemove(index1) ) {\n        removed.push(index1);\n        newIndex[index1] = REMOVED_INDEX;\n      } else {\n        newIndex[index1] = index2++;\n      }\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(-1, -1, [], removed, true); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n      if ( newIndex[index3] !== REMOVED_INDEX ) {\n        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n        ++index4;\n      }\n    }\n\n    data.length = n = index4;\n    filters.truncate(index4);\n    triggerOnChange('dataRemoved');\n  }\n\n  function maskForDimensions(dimensions) {\n    var n,\n        d,\n        len,\n        id,\n        mask = Array(filters.subarrays);\n    for (n = 0; n < filters.subarrays; n++) { mask[n] = ~0; }\n    for (d = 0, len = dimensions.length; d < len; d++) {\n      // The top bits of the ID are the subarray offset and the lower bits are the bit\n      // offset of the \"one\" mask.\n      id = dimensions[d].id();\n      mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n    }\n    return mask;\n  }\n\n  // Return true if the data element at index i is filtered IN.\n  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n  function isElementFiltered(i, ignore_dimensions) {\n    var mask = maskForDimensions(ignore_dimensions || []);\n    return filters.zeroExceptMask(i,mask);\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value, iterable) {\n\n    if (typeof value === 'string') {\n      var accessorPath = value;\n      value = function(d) { return result(d, accessorPath); };\n    }\n\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      currentFilter: currentFilter,\n      hasCurrentFilter: hasCurrentFilter,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose, // for backwards-compatibility\n      accessor: value,\n      id: function() { return id; }\n    };\n\n    var one, // lowest unset bit as mask, e.g., 00001000\n        zero, // inverted one, e.g., 11110111\n        offset, // offset into the filters arrays\n        id, // unique ID for this dimension (reused when dimensions are disposed)\n        values, // sorted, cached array\n        index, // maps sorted value index -> record index (in data)\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        iterablesIndexCount,\n        iterablesIndexFilterStatus,\n        iterablesEmptyRows = [],\n        sortRange = function(n) {\n          return cr_range(n).sort(function(A, B) {\n            var a = newValues[A], b = newValues[B];\n            return a < b ? -1 : a > b ? 1 : A - B;\n          });\n        },\n        refilter = xfilterFilter.filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        filterValue, // the value used for filtering (value, array, function or undefined)\n        filterValuePresent, // true if filterValue contains something\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0,\n        t = 0,\n        k;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Add a new dimension in the filter bitmap and store the offset and bitmask.\n    var tmp = filters.add();\n    offset = tmp.offset;\n    one = tmp.one;\n    zero = ~one;\n\n    // Create a unique ID for the dimension\n    // IDs will be re-used if dimensions are disposed.\n    // For internal use the ID is the subarray offset shifted left 7 bits or'd with the\n    // bit offset of the set bit in the dimension's \"one\" mask.\n    id = (offset << 7) | (Math.log(one) / Math.log(2));\n\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n      var newIterablesIndexCount,\n          newIterablesIndexFilterStatus;\n\n      if (iterable){\n        // Count all the values\n        t = 0;\n        j = 0;\n        k = [];\n\n        for (var i0 = 0; i0 < newData.length; i0++) {\n          for(j = 0, k = value(newData[i0]); j < k.length; j++) {\n            t++;\n          }\n        }\n\n        newValues = [];\n        newIterablesIndexCount = cr_range(newData.length);\n        newIterablesIndexFilterStatus = cr_index(t,1);\n        var unsortedIndex = cr_range(t);\n\n        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n          k = value(newData[index1])\n          //\n          if(!k.length){\n            newIterablesIndexCount[index1] = 0;\n            iterablesEmptyRows.push(index1 + n0);\n            continue;\n          }\n          newIterablesIndexCount[index1] = k.length\n          for (j = 0; j < k.length; j++) {\n            newValues.push(k[j]);\n            unsortedIndex[l] = index1;\n            l++;\n          }\n        }\n\n        // Create the Sort map used to sort both the values and the valueToData indices\n        var sortMap = sortRange(t);\n\n        // Use the sortMap to sort the newValues\n        newValues = permute(newValues, sortMap);\n\n\n        // Use the sortMap to sort the unsortedIndex map\n        // newIndex should be a map of sortedValue -> crossfilterData\n        newIndex = permute(unsortedIndex, sortMap)\n\n      } else{\n        // Permute new values into natural order using a standard sorted index.\n        newValues = newData.map(value);\n        newIndex = sortRange(n1);\n        newValues = permute(newValues, newIndex);\n      }\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];\n\n      var index2, index3, index4;\n      if(iterable) {\n        n1 = t;\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              if(--newIterablesIndexCount[newIndex[index2]] === 0) {\n                filters[offset][newIndex[index2] + n0] |= one;\n              }\n              newIterablesIndexFilterStatus[index2] = 1;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            if(--newIterablesIndexCount[newIndex[index3]] === 0) {\n              filters[offset][newIndex[index3] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index3] = 1;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            if(--newIterablesIndexCount[newIndex[index4]] === 0) {\n              filters[offset][newIndex[index4] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index4] = 1;\n          }\n        }\n      } else {\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              filters[offset][newIndex[index2] + n0] |= one;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            filters[offset][newIndex[index3] + n0] |= one;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            filters[offset][newIndex[index4] + n0] |= one;\n          }\n        }\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        iterablesIndexCount = newIterablesIndexCount;\n        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n\n\n      var oldValues = values,\n        oldIndex = index,\n        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n        old_n0,\n        i1 = 0;\n\n      i0 = 0;\n\n      if(iterable){\n        old_n0 = n0\n        n0 = oldValues.length;\n        n1 = t\n      }\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = iterable ? new Array(n0 + n1) : new Array(n);\n      index = iterable ? new Array(n0 + n1) : cr_index(n, n);\n      if(iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);\n\n      // Concatenate the newIterablesIndexCount onto the old one.\n      if(iterable) {\n        var oldiiclength = iterablesIndexCount.length;\n        iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n        for(var j=0; j+oldiiclength < n; j++) {\n          iterablesIndexCount[j+oldiiclength] = newIterablesIndexCount[j];\n        }\n      }\n\n      // Merge the old and new sorted values, and old and new index.\n      var index5 = 0;\n      for (; i0 < n0 && i1 < n1; ++index5) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[index5] = oldValues[i0];\n          if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0++];\n        } else {\n          values[index5] = newValues[i1];\n          if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++index5) {\n        values[index5] = oldValues[i0];\n        if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n        index[index5] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++index5) {\n        values[index5] = newValues[i1];\n        if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      if (iterable) {\n        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n            i1++;\n          }\n        }\n        iterablesEmptyRows.length = i1;\n        for (i0 = 0, i1 = 0; i0 < n; i0++) {\n          if (reIndex[i0] !== REMOVED_INDEX) {\n            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n            i1++;\n          }\n        }\n        iterablesIndexCount = iterablesIndexCount.slice(0, i1);\n      }\n      // Rewrite our index, overwriting removed values\n      var n0 = values.length;\n      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n        oldDataIndex = index[i];\n        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[oldDataIndex];\n          if (iterable) {\n            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n          }\n          ++j;\n        }\n      }\n      values.length = j;\n      if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);\n      while (j < n0) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; }, bounds[0] === 0 && bounds[1] === values.length);\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [];\n\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      if(!iterable) {\n        // Flip filters normally.\n\n        for(i=0; i<added.length; i++) {\n          filters[offset][added[i]] ^= one;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          filters[offset][removed[i]] ^= one;\n        }\n\n      } else {\n        // For iterables, we need to figure out if the row has been completely removed vs partially included\n        // Only count a row as added if it is not already being aggregated. Only count a row\n        // as removed if the last element being aggregated is removed.\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          iterablesIndexCount[added[i]]++\n          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n          if(iterablesIndexCount[added[i]] === 1) {\n            filters[offset][added[i]] ^= one;\n            newAdded.push(added[i]);\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          iterablesIndexCount[removed[i]]--\n          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n          if(iterablesIndexCount[removed[i]] === 0) {\n            filters[offset][removed[i]] ^= one;\n            newRemoved.push(removed[i]);\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(refilter === xfilterFilter.filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      filterValue = value;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      filterValue = range;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      filterValue = undefined;\n      filterValuePresent = false;\n      return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      filterValue = f;\n      filterValuePresent = true;\n      \n      refilterFunction = f;\n      refilter = xfilterFilter.filterAll;\n\n      filterIndexFunction(f, false);\n\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f, filterAll) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [],\n          indexLength = values.length;\n\n      if(!iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) added.push(k);\n            else removed.push(k);\n          }\n        }\n      }\n\n      if(iterable) {\n        for(i=0; i < indexLength; ++i) {\n          if(f(values[i], i)) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          } else {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n      }\n\n      if(!iterable) {\n        for(i=0; i<added.length; i++) {\n          if(filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          if(!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n        }\n      } else {\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          // First check this particular value needs to be added\n          if(iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n            iterablesIndexCount[added[i]]++\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n            if(iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          // First check this particular value needs to be removed\n          if(iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n            iterablesIndexCount[removed[i]]--\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n            if(iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n    }\n    \n    function currentFilter() {\n      return filterValue;\n    }\n    \n    function hasCurrentFilter() {\n      return filterValuePresent;\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k, top_offset) {\n      var array = [],\n          i = hi0,\n          j,\n          toSkip = 0;\n\n      if(top_offset && top_offset > 0) toSkip = top_offset;\n\n      while (--i >= lo0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n      }\n\n      if(iterable){\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          // Add row with empty iterable column at the end\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k, bottom_offset) {\n      var array = [],\n          i,\n          j,\n          toSkip = 0;\n\n      if(bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n\n      if(iterable) {\n        // Add row with empty iterable column at the top\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      i = lo0;\n\n      while (i < hi0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id ↦ group id\n          groupWidth = 8,\n          groupCapacity = capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = cr_null,\n          reset = cr_null,\n          resetNeeded = true,\n          groupAll = key === cr_null,\n          n0old;\n\n      if (arguments.length < 1) key = cr_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n\n        if(iterable) {\n          n0old = n0\n          n0 = values.length - newValues.length\n          n1 = newValues.length;\n        }\n\n        var oldGroups = groups,\n            reIndex = iterable ? [] : cr_index(k, groupCapacity),\n            add = reduceAdd,\n            remove = reduceRemove,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = cr_null;\n        if (resetNeeded) remove = initial = cr_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        if(iterable){\n          groupIndex = k0 ? groupIndex : [];\n        }\n        else{\n          groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);\n        }\n\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain…\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            g0 = oldGroups[++i0];\n            if (g0) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n\n          while (x1 <= x) {\n            j = newIndex[i1] + (iterable ? n0old : n0)\n\n\n            if(iterable){\n              if(groupIndex[j]){\n                groupIndex[j].push(k)\n              }\n              else{\n                groupIndex[j] = [k]\n              }\n            }\n            else{\n              groupIndex[j] = k;\n            }\n\n            // Always add new values to groups. Only remove when not in filter.\n            // This gives groups full information on data life-cycle.\n            g.value = add(g.value, data[j], true);\n            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater th1an all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n\n        // Fill in gaps with empty arrays where there may have been rows with empty iterables\n        if(iterable){\n          for (var index1 = 0; index1 < n; index1++) {\n            if(!groupIndex[index1]){\n              groupIndex[index1] = [];\n            }\n          }\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if(k > i0){\n          if(iterable){\n            for (i0 = 0; i0 < n0old; ++i0) {\n              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n              }\n            }\n          }\n          else{\n            for (i0 = 0; i0 < n0; ++i0) {\n              groupIndex[i0] = reIndex[groupIndex[i0]];\n            }\n          }\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1 || iterable) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = cr_null;\n            reset = cr_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if(iterable){\n            k++\n            return\n          }\n          if (++k === groupCapacity) {\n            reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n            groupCapacity = capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData(reIndex) {\n        if (k > 1 || iterable) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = cr_index(oldK, oldK),\n              i,\n              i0,\n              j;\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          if (!iterable) {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            }\n          } else {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                groupIndex[j] = groupIndex[i];\n                for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                  seenGroups[groupIndex[j][i0]] = 1;\n                }\n                ++j;\n              }\n            }\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1 || iterable) {\n            // Reindex the group index using seenGroups to find the new index.\n            if (!iterable) {\n              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n            } else {\n              for (i = 0; i < j; ++i) {\n                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                }\n              }\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = cr_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = cr_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            j,\n            k,\n            n,\n            g;\n\n        if(iterable){\n          // Add the added values.\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceAdd(g.value, data[k], false, j);\n              }\n            }\n          }\n\n          // Remove the removed values.\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceRemove(g.value, data[k], notFilter, j);\n              }\n            }\n          }\n          return;\n        }\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            j,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        if(iterable){\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < groupIndex[i].length; j++) {\n              g = groups[groupIndex[i][j]];\n              g.value = reduceAdd(g.value, data[i], true, j);\n            }\n          }\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceRemove(g.value, data[i], false, j);\n              }\n            }\n          }\n          return;\n        }\n\n        for (i = 0; i < n; ++i) {\n          g = groups[groupIndex[i]];\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        for (i = 0; i < n; ++i) {\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = xfilterHeapselect.by(valueOf);\n        heap = xfilterHeap.by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(cr_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        i = dimensionGroups.indexOf(group);\n        if (i >= 0) dimensionGroups.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(cr_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      filters.masks[offset] &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Cycle through all the values.\n      for (i = n0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, filterOffset, added, removed, notFilter) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (filters.zero(k = added[i])) {\n          reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters.only(k = removed[i], filterOffset, filterOne)) {\n          reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      // Cycle through all the values.\n      for (i = 0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if it is filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i, 1);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i, 1);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  // Returns the raw row data contained in this crossfilter\n  function all(){\n    return data;\n  }\n\n  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n  function allFiltered(ignore_dimensions) {\n    var array = [],\n        i = 0,\n        mask = maskForDimensions(ignore_dimensions || []);\n\n      for (i = 0; i < n; i++) {\n        if (filters.zeroExceptMask(i, mask)) {\n          array.push(data[i]);\n        }\n      }\n\n      return array;\n  }\n\n  function onChange(cb){\n    if(typeof cb !== 'function'){\n      /* eslint no-console: 0 */\n      console.warn('onChange callback parameter must be a function!');\n      return;\n    }\n    callbacks.push(cb);\n    return function(){\n      callbacks.splice(callbacks.indexOf(cb), 1);\n    };\n  }\n\n  function triggerOnChange(eventName){\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](eventName);\n    }\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction cr_index(n, m) {\n  return (m < 0x101\n      ? xfilterArray.array8 : m < 0x10001\n      ? xfilterArray.array16\n      : xfilterArray.array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction cr_range(n) {\n  var range = cr_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n"],"names":["array8","arrayUntyped","array16","array32","arrayLengthen","arrayLengthenUntyped","arrayWiden","arrayWidenUntyped","n","array","Array","i","length","width","Error","bitarray","subarrays","masks","Uint8Array","Uint16Array","Uint32Array","copy","constructor","set","prototype","lengthen","len","this","add","m","w","one","offset","dest","src","truncate","j","zero","zeroExcept","zeroExceptMask","mask","only","onlyExcept","onlyOffset","onlyOne","bisect","value","values","left","right","range","min","max","d","heap_by","f","heap","a","lo","hi","sift","child","x","sort","t","h","identity","heapselect_by","xFilterHeap","by","k","queue","Math","bisect_by","bisectRight","mid","index","deep","JSON","parse","stringify","p","v","get","obj","prop","call","reg","path","action","keys","id","key","split","splice","replace","crossfilter","filters","remove","removeData","dimension","groupAll","size","all","allFiltered","onChange","isElementFiltered","data","filterListeners","dataListeners","removeDataListeners","callbacks","newData","n0","n1","concat","forEach","l","triggerOnChange","predicate","newIndex","removed","usePred","index1","index2","push","index3","index4","maskForDimensions","dimensions","ignore_dimensions","iterable","accessorPath","result","newValues","iterablesIndexCount","iterablesIndexFilterStatus","refilterFunction","filterValue","filterValuePresent","filter","filterAll","isArray","filterRange","filterFunction","filterExact","currentFilter","hasCurrentFilter","top","top_offset","hi0","toSkip","lo0","iterablesEmptyRows","bottom","bottom_offset","group","g","cr_null","order","orderNatural","dispose","accessor","sortRange","cr_range","A","B","b","refilter","xfilterFilter","indexListeners","dimensionGroups","unshift","preAdd","postAdd","tmp","newIterablesIndexCount","newIterablesIndexFilterStatus","i0","cr_index","unsortedIndex","sortMap","permute","map","bounds","lo1","hi1","old_n0","oldValues","oldIndex","oldIterablesIndexFilterStatus","i1","oldiiclength","xfilterArray","index5","reIndex","slice","oldDataIndex","filterIndexBounds","filterIndexFunction","added","valueIndexAdded","valueIndexRemoved","newAdded","newRemoved","undefined","indexLength","reduce","reduceCount","reduceSum","groups","groupIndex","select","reduceAdd","reduceRemove","reduceInitial","n0old","groupWidth","groupCapacity","capacity","update","reset","resetNeeded","g0","x0","x1","oldGroups","initial","k0","groupIncrement","indexOf","updateMany","resetMany","updateOne","resetOne","oldK","seenGroups","filterOne","filterOffset","notFilter","xfilterReduce","cr_zero","valueOf","xfilterHeapselect","xfilterHeap","cr_identity","arguments","log","reduceValue","cb","console","warn","eventName","heapselect"],"mappings":"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"}