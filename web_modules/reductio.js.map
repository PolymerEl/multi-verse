{"version":3,"file":"reductio.js","sources":["../../reductio/src/filter.js","../../reductio/src/count.js","../../reductio/src/sum.js","../../reductio/src/avg.js","../../reductio/src/median.js","../../reductio/src/min.js","../../reductio/src/max.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/array.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/filter.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/identity.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/null.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/zero.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/heap.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/heapselect.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/bisect.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/permute.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/reduce.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/result.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/@ranfdev/deepobj/1.0.2/node_modules/@ranfdev/deepobj/dist/deepobj.m.js","../../reductio/node_modules/.pnpm/registry.npmjs.org/crossfilter2/1.5.2/node_modules/crossfilter2/src/index.js","../../reductio/src/value-count.js","../../reductio/src/value-list.js","../../reductio/src/exception-count.js","../../reductio/src/exception-sum.js","../../reductio/src/histogram.js","../../reductio/src/sum-of-squares.js","../../reductio/src/std.js","../../reductio/src/nest.js","../../reductio/src/alias.js","../../reductio/src/aliasProp.js","../../reductio/src/data-list.js","../../reductio/src/custom.js","../../reductio/src/build.js","../../reductio/src/accessors.js","../../reductio/src/parameters.js","../../reductio/src/cap.js","../../reductio/src/sortBy.js","../../reductio/src/reductio.js","../../reductio/src/postprocessors.js","../../reductio/src/postprocess.js"],"sourcesContent":["var filter = {\n\t// The big idea here is that you give us a filter function to run on values,\n\t// a 'prior' reducer to run (just like the rest of the standard reducers),\n\t// and a reference to the last reducer (called 'skip' below) defined before\n\t// the most recent chain of reducers.  This supports individual filters for\n\t// each .value('...') chain that you add to your reducer.\n\tadd: function (filter, prior, skip) {\n\t\treturn function (p, v, nf) {\n\t\t\tif (filter(v, nf)) {\n\t\t\t\tif (prior) prior(p, v, nf);\n\t\t\t} else {\n\t\t\t\tif (skip) skip(p, v, nf);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (filter, prior, skip) {\n\t\treturn function (p, v, nf) {\n\t\t\tif (filter(v, nf)) {\n\t\t\t\tif (prior) prior(p, v, nf);\n\t\t\t} else {\n\t\t\t\tif (skip) skip(p, v, nf);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default filter;\n","var count = {\n\tadd: function(prior, path, propName) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p)[propName]++;\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function(prior, path, propName) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p)[propName]--;\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function(prior, path, propName) {\n\t\treturn function (p) {\n\t\t\tif(prior) p = prior(p);\n\t\t\t// if(p === undefined) p = {};\n\t\t\tpath(p)[propName] = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default count;","var sum = {\n\tadd: function (a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p).sum = path(p).sum + a(v);\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p).sum = path(p).sum - a(v);\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).sum = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default sum;","var avg = {\n\tadd: function (a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tif(path(p).count > 0) {\n\t\t\t\tpath(p).avg = path(p).sum / path(p).count;\n\t\t\t} else {\n\t\t\t\tpath(p).avg = 0;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tif(path(p).count > 0) {\n\t\t\t\tpath(p).avg = path(p).sum / path(p).count;\n\t\t\t} else {\n\t\t\t\tpath(p).avg = 0;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).avg = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default avg;","var median = {\n\tadd: function (prior, path) {\n\t\tvar half;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\n\t\t\thalf = Math.floor(path(p).valueList.length/2);\n \n\t\t\tif(path(p).valueList.length % 2) {\n\t\t\t\tpath(p).median = path(p).valueList[half];\n\t\t\t} else {\n\t\t\t\tpath(p).median = (path(p).valueList[half-1] + path(p).valueList[half]) / 2.0;\n\t\t\t}\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (prior, path) {\n\t\tvar half;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\n\t\t\thalf = Math.floor(path(p).valueList.length/2);\n\n\t\t\t// Check for undefined.\n\t\t\tif(path(p).valueList.length === 0) {\n\t\t\t\tpath(p).median = undefined;\n\t\t\t\treturn p;\n\t\t\t}\n \n\t\t\tif(path(p).valueList.length === 1 || path(p).valueList.length % 2) {\n\t\t\t\tpath(p).median = path(p).valueList[half];\n\t\t\t} else {\n\t\t\t\tpath(p).median = (path(p).valueList[half-1] + path(p).valueList[half]) / 2.0;\n\t\t\t}\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).median = undefined;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default median;","var min = {\n\tadd: function (prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n \n\t\t\tpath(p).min = path(p).valueList[0];\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\n\t\t\t// Check for undefined.\n\t\t\tif(path(p).valueList.length === 0) {\n\t\t\t\tpath(p).min = undefined;\n\t\t\t\treturn p;\n\t\t\t}\n \n\t\t\tpath(p).min = path(p).valueList[0];\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).min = undefined;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default min;","var max = {\n\tadd: function (prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n \n\t\t\tpath(p).max = path(p).valueList[path(p).valueList.length - 1];\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\n\t\t\t// Check for undefined.\n\t\t\tif(path(p).valueList.length === 0) {\n\t\t\t\tpath(p).max = undefined;\n\t\t\t\treturn p;\n\t\t\t}\n \n\t\t\tpath(p).max = path(p).valueList[path(p).valueList.length - 1];\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).max = undefined;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default max;","let array8 = arrayUntyped,\n    array16 = arrayUntyped,\n    array32 = arrayUntyped,\n    arrayLengthen = arrayLengthenUntyped,\n    arrayWiden = arrayWidenUntyped;\nif (typeof Uint8Array !== \"undefined\") {\n  array8 = function(n) { return new Uint8Array(n); };\n  array16 = function(n) { return new Uint16Array(n); };\n  array32 = function(n) { return new Uint32Array(n); };\n\n  arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = array16(array.length); break;\n      case 32: copy = array32(array.length); break;\n      default: throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\n\n// An arbitrarily-wide array of bitmasks\nfunction bitarray(n) {\n  this.length = n;\n  this.subarrays = 1;\n  this.width = 8;\n  this.masks = {\n    0: 0\n  }\n\n  this[0] = array8(n);\n}\n\nbitarray.prototype.lengthen = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i] = arrayLengthen(this[i], n);\n  }\n  this.length = n;\n};\n\n// Reserve a new bit index in the array, returns {offset, one}\nbitarray.prototype.add = function() {\n  var m, w, one, i, len;\n\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    m = this.masks[i];\n    w = this.width - (32 * i);\n    // isolate the rightmost zero bit and return it as an unsigned int of 32 bits, if NaN or -1, return a 0 \n    one = (~m & (m + 1)) >>> 0;\n\n    if (w >= 32 && !one) {\n      continue;\n    }\n\n    if (w < 32 && (one & (1 << w))) {\n      // widen this subarray\n      this[i] = arrayWiden(this[i], w <<= 1);\n      this.width = 32 * i + w;\n    }\n\n    this.masks[i] |= one;\n\n    return {\n      offset: i,\n      one: one\n    };\n  }\n\n  // add a new subarray\n  this[this.subarrays] = array8(this.length);\n  this.masks[this.subarrays] = 1;\n  this.width += 8;\n  return {\n    offset: this.subarrays++,\n    one: 1\n  };\n};\n\n// Copy record from index src to index dest\nbitarray.prototype.copy = function(dest, src) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i][dest] = this[i][src];\n  }\n};\n\n// Truncate the array to the given length\nbitarray.prototype.truncate = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    for (var j = this.length - 1; j >= n; j--) {\n      this[i][j] = 0;\n    }\n  }\n  this.length = n;\n};\n\n// Checks that all bits for the given index are 0\nbitarray.prototype.zero = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for possibly one\nbitarray.prototype.zeroExcept = function(n, offset, zero) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (i === offset ? this[i][n] & zero : this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for the specified mask.\n// The mask should be an array of the same size as the filter subarrays width.\nbitarray.prototype.zeroExceptMask = function(n, mask) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] & mask[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks that only the specified bit is set for the given index\nbitarray.prototype.only = function(n, offset, one) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] != (i === offset ? one : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that only the specified bit is set for the given index except for possibly one other\nbitarray.prototype.onlyExcept = function(n, offset, zero, onlyOffset, onlyOne) {\n  var mask;\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    mask = this[i][n];\n    if (i === offset)\n      mask &= zero;\n    if (mask != (i === onlyOffset ? onlyOne : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport default {\n  array8: arrayUntyped,\n  array16: arrayUntyped,\n  array32: arrayUntyped,\n  arrayLengthen: arrayLengthenUntyped,\n  arrayWiden: arrayWidenUntyped,\n  bitarray: bitarray\n};\n","const filterExact = (bisect, value) => {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nconst filterRange = (bisect, range) => {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nconst filterAll = values => {\n  return [0, values.length];\n}\n\nexport default {\n  filterExact,\n  filterRange,\n  filterAll\n};\n","export default d => {\n  return d;\n};\n","export default () =>  {\n  return null;\n}\n","export default () => {\n  return 0;\n}\n","import identity from './identity';\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\n\nconst h = heap_by(identity);\nh.by = heap_by;\n\nexport default h;\n","import identity from './identity';\nimport xFilterHeap from './heap';\n\nfunction heapselect_by(f) {\n  var heap = xFilterHeap.by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\n\n\nconst h = heapselect_by(identity);\nh.by = heapselect_by; // assign the raw function to the export as well\n\nexport default h;\n","import identity from './identity';\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\n\nconst bisect = bisect_by(identity);\nbisect.by = bisect_by; // assign the raw function to the export as well\n\nexport default bisect;\n\n","export default (array, index, deep) => {\n  for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\n","const reduceIncrement = p => {\n  return p + 1;\n}\n\nconst reduceDecrement = p => {\n  return p - 1;\n}\n\nconst reduceAdd = f => {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nconst reduceSubtract = f => {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\n\nexport default {\n  reduceIncrement,\n  reduceDecrement,\n  reduceAdd,\n  reduceSubtract\n};\n","import deep from \"@ranfdev/deepobj\"\n// Note(cg): result was previsouly using lodash.result, not ESM compatible.\n \nconst get = (obj, prop) => {\n  const value = obj[prop];\n  return (typeof value === 'function') ? value.call(obj) : value;\n}\n\n/**\n * get value of object at a deep path.\n * if the resolved value is a function,\n * it's invoked with the `this` binding of \n * its parent object and its result is returned. \n *  \n * @param  {Object} obj  the object (e.g. { 'a': [{ 'b': { 'c1': 3, 'c2': 4} }], 'd': {e:1} }; )\n * @param  {String} path deep path (e.g. `d.e`` or `a[0].b.c1`. Dot notation (a.0.b)is also supported)\n * @return {Any}      the resolved value\n */\nconst reg = /\\[([\\w\\d]+)\\]/g;\nexport default (obj, path) => {\n  return deep(get, obj, path.replace(reg, '.$1'))\n}\n","export default function(t,e,i,n,r){for(r in n=(i=i.split(\".\")).splice(-1,1),i)e=e[i[r]]=e[i[r]]||{};return t(e,n)};\n//# sourceMappingURL=deepobj.m.js.map\n","import xfilterArray from './array';\nimport xfilterFilter from './filter';\nimport cr_identity from './identity';\nimport cr_null from './null';\nimport cr_zero from './zero';\nimport xfilterHeapselect from './heapselect';\nimport xfilterHeap from './heap';\nimport bisect from './bisect';\nimport permute from './permute';\nimport xfilterReduce from './reduce';\nimport result from './result';\n\n// constants\nvar REMOVED_INDEX = -1;\n\ncrossfilter.heap = xfilterHeap;\ncrossfilter.heapselect = xfilterHeapselect;\ncrossfilter.bisect = bisect;\ncrossfilter.permute = permute;\nexport default crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size,\n    all: all,\n    allFiltered: allFiltered,\n    onChange: onChange,\n    isElementFiltered: isElementFiltered\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      filters, // 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = [], // when data is removed\n      callbacks = [];\n\n  filters = new xfilterArray.bitarray(0);\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add…\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters.lengthen(n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n      triggerOnChange('dataAdded');\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters, or if a predicate function is passed,\n  // removes all records matching the predicate (ignoring filters).\n  function removeData(predicate) {\n    var // Mapping from old record indexes to new indexes (after records removed)\n        newIndex = new Array(n),\n        removed = [],\n        usePred = typeof predicate === 'function',\n        shouldRemove = function (i) {\n          return usePred ? predicate(data[i], i) : filters.zero(i)\n        };\n\n    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n      if ( shouldRemove(index1) ) {\n        removed.push(index1);\n        newIndex[index1] = REMOVED_INDEX;\n      } else {\n        newIndex[index1] = index2++;\n      }\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(-1, -1, [], removed, true); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n      if ( newIndex[index3] !== REMOVED_INDEX ) {\n        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n        ++index4;\n      }\n    }\n\n    data.length = n = index4;\n    filters.truncate(index4);\n    triggerOnChange('dataRemoved');\n  }\n\n  function maskForDimensions(dimensions) {\n    var n,\n        d,\n        len,\n        id,\n        mask = Array(filters.subarrays);\n    for (n = 0; n < filters.subarrays; n++) { mask[n] = ~0; }\n    for (d = 0, len = dimensions.length; d < len; d++) {\n      // The top bits of the ID are the subarray offset and the lower bits are the bit\n      // offset of the \"one\" mask.\n      id = dimensions[d].id();\n      mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n    }\n    return mask;\n  }\n\n  // Return true if the data element at index i is filtered IN.\n  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n  function isElementFiltered(i, ignore_dimensions) {\n    var mask = maskForDimensions(ignore_dimensions || []);\n    return filters.zeroExceptMask(i,mask);\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value, iterable) {\n\n    if (typeof value === 'string') {\n      var accessorPath = value;\n      value = function(d) { return result(d, accessorPath); };\n    }\n\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      currentFilter: currentFilter,\n      hasCurrentFilter: hasCurrentFilter,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose, // for backwards-compatibility\n      accessor: value,\n      id: function() { return id; }\n    };\n\n    var one, // lowest unset bit as mask, e.g., 00001000\n        zero, // inverted one, e.g., 11110111\n        offset, // offset into the filters arrays\n        id, // unique ID for this dimension (reused when dimensions are disposed)\n        values, // sorted, cached array\n        index, // maps sorted value index -> record index (in data)\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        iterablesIndexCount,\n        iterablesIndexFilterStatus,\n        iterablesEmptyRows = [],\n        sortRange = function(n) {\n          return cr_range(n).sort(function(A, B) {\n            var a = newValues[A], b = newValues[B];\n            return a < b ? -1 : a > b ? 1 : A - B;\n          });\n        },\n        refilter = xfilterFilter.filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        filterValue, // the value used for filtering (value, array, function or undefined)\n        filterValuePresent, // true if filterValue contains something\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0,\n        t = 0,\n        k;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Add a new dimension in the filter bitmap and store the offset and bitmask.\n    var tmp = filters.add();\n    offset = tmp.offset;\n    one = tmp.one;\n    zero = ~one;\n\n    // Create a unique ID for the dimension\n    // IDs will be re-used if dimensions are disposed.\n    // For internal use the ID is the subarray offset shifted left 7 bits or'd with the\n    // bit offset of the set bit in the dimension's \"one\" mask.\n    id = (offset << 7) | (Math.log(one) / Math.log(2));\n\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n      var newIterablesIndexCount,\n          newIterablesIndexFilterStatus;\n\n      if (iterable){\n        // Count all the values\n        t = 0;\n        j = 0;\n        k = [];\n\n        for (var i0 = 0; i0 < newData.length; i0++) {\n          for(j = 0, k = value(newData[i0]); j < k.length; j++) {\n            t++;\n          }\n        }\n\n        newValues = [];\n        newIterablesIndexCount = cr_range(newData.length);\n        newIterablesIndexFilterStatus = cr_index(t,1);\n        var unsortedIndex = cr_range(t);\n\n        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n          k = value(newData[index1])\n          //\n          if(!k.length){\n            newIterablesIndexCount[index1] = 0;\n            iterablesEmptyRows.push(index1 + n0);\n            continue;\n          }\n          newIterablesIndexCount[index1] = k.length\n          for (j = 0; j < k.length; j++) {\n            newValues.push(k[j]);\n            unsortedIndex[l] = index1;\n            l++;\n          }\n        }\n\n        // Create the Sort map used to sort both the values and the valueToData indices\n        var sortMap = sortRange(t);\n\n        // Use the sortMap to sort the newValues\n        newValues = permute(newValues, sortMap);\n\n\n        // Use the sortMap to sort the unsortedIndex map\n        // newIndex should be a map of sortedValue -> crossfilterData\n        newIndex = permute(unsortedIndex, sortMap)\n\n      } else{\n        // Permute new values into natural order using a standard sorted index.\n        newValues = newData.map(value);\n        newIndex = sortRange(n1);\n        newValues = permute(newValues, newIndex);\n      }\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];\n\n      var index2, index3, index4;\n      if(iterable) {\n        n1 = t;\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              if(--newIterablesIndexCount[newIndex[index2]] === 0) {\n                filters[offset][newIndex[index2] + n0] |= one;\n              }\n              newIterablesIndexFilterStatus[index2] = 1;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            if(--newIterablesIndexCount[newIndex[index3]] === 0) {\n              filters[offset][newIndex[index3] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index3] = 1;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            if(--newIterablesIndexCount[newIndex[index4]] === 0) {\n              filters[offset][newIndex[index4] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index4] = 1;\n          }\n        }\n      } else {\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              filters[offset][newIndex[index2] + n0] |= one;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            filters[offset][newIndex[index3] + n0] |= one;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            filters[offset][newIndex[index4] + n0] |= one;\n          }\n        }\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        iterablesIndexCount = newIterablesIndexCount;\n        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n\n\n      var oldValues = values,\n        oldIndex = index,\n        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n        old_n0,\n        i1 = 0;\n\n      i0 = 0;\n\n      if(iterable){\n        old_n0 = n0\n        n0 = oldValues.length;\n        n1 = t\n      }\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = iterable ? new Array(n0 + n1) : new Array(n);\n      index = iterable ? new Array(n0 + n1) : cr_index(n, n);\n      if(iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);\n\n      // Concatenate the newIterablesIndexCount onto the old one.\n      if(iterable) {\n        var oldiiclength = iterablesIndexCount.length;\n        iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n        for(var j=0; j+oldiiclength < n; j++) {\n          iterablesIndexCount[j+oldiiclength] = newIterablesIndexCount[j];\n        }\n      }\n\n      // Merge the old and new sorted values, and old and new index.\n      var index5 = 0;\n      for (; i0 < n0 && i1 < n1; ++index5) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[index5] = oldValues[i0];\n          if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0++];\n        } else {\n          values[index5] = newValues[i1];\n          if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++index5) {\n        values[index5] = oldValues[i0];\n        if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n        index[index5] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++index5) {\n        values[index5] = newValues[i1];\n        if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      if (iterable) {\n        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n            i1++;\n          }\n        }\n        iterablesEmptyRows.length = i1;\n        for (i0 = 0, i1 = 0; i0 < n; i0++) {\n          if (reIndex[i0] !== REMOVED_INDEX) {\n            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n            i1++;\n          }\n        }\n        iterablesIndexCount = iterablesIndexCount.slice(0, i1);\n      }\n      // Rewrite our index, overwriting removed values\n      var n0 = values.length;\n      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n        oldDataIndex = index[i];\n        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[oldDataIndex];\n          if (iterable) {\n            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n          }\n          ++j;\n        }\n      }\n      values.length = j;\n      if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);\n      while (j < n0) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; }, bounds[0] === 0 && bounds[1] === values.length);\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [];\n\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      if(!iterable) {\n        // Flip filters normally.\n\n        for(i=0; i<added.length; i++) {\n          filters[offset][added[i]] ^= one;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          filters[offset][removed[i]] ^= one;\n        }\n\n      } else {\n        // For iterables, we need to figure out if the row has been completely removed vs partially included\n        // Only count a row as added if it is not already being aggregated. Only count a row\n        // as removed if the last element being aggregated is removed.\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          iterablesIndexCount[added[i]]++\n          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n          if(iterablesIndexCount[added[i]] === 1) {\n            filters[offset][added[i]] ^= one;\n            newAdded.push(added[i]);\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          iterablesIndexCount[removed[i]]--\n          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n          if(iterablesIndexCount[removed[i]] === 0) {\n            filters[offset][removed[i]] ^= one;\n            newRemoved.push(removed[i]);\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(refilter === xfilterFilter.filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      filterValue = value;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      filterValue = range;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      filterValue = undefined;\n      filterValuePresent = false;\n      return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      filterValue = f;\n      filterValuePresent = true;\n      \n      refilterFunction = f;\n      refilter = xfilterFilter.filterAll;\n\n      filterIndexFunction(f, false);\n\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f, filterAll) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [],\n          indexLength = values.length;\n\n      if(!iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) added.push(k);\n            else removed.push(k);\n          }\n        }\n      }\n\n      if(iterable) {\n        for(i=0; i < indexLength; ++i) {\n          if(f(values[i], i)) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          } else {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n      }\n\n      if(!iterable) {\n        for(i=0; i<added.length; i++) {\n          if(filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          if(!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n        }\n      } else {\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          // First check this particular value needs to be added\n          if(iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n            iterablesIndexCount[added[i]]++\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n            if(iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          // First check this particular value needs to be removed\n          if(iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n            iterablesIndexCount[removed[i]]--\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n            if(iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n    }\n    \n    function currentFilter() {\n      return filterValue;\n    }\n    \n    function hasCurrentFilter() {\n      return filterValuePresent;\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k, top_offset) {\n      var array = [],\n          i = hi0,\n          j,\n          toSkip = 0;\n\n      if(top_offset && top_offset > 0) toSkip = top_offset;\n\n      while (--i >= lo0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n      }\n\n      if(iterable){\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          // Add row with empty iterable column at the end\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k, bottom_offset) {\n      var array = [],\n          i,\n          j,\n          toSkip = 0;\n\n      if(bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n\n      if(iterable) {\n        // Add row with empty iterable column at the top\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      i = lo0;\n\n      while (i < hi0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id ↦ group id\n          groupWidth = 8,\n          groupCapacity = capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = cr_null,\n          reset = cr_null,\n          resetNeeded = true,\n          groupAll = key === cr_null,\n          n0old;\n\n      if (arguments.length < 1) key = cr_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n\n        if(iterable) {\n          n0old = n0\n          n0 = values.length - newValues.length\n          n1 = newValues.length;\n        }\n\n        var oldGroups = groups,\n            reIndex = iterable ? [] : cr_index(k, groupCapacity),\n            add = reduceAdd,\n            remove = reduceRemove,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = cr_null;\n        if (resetNeeded) remove = initial = cr_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        if(iterable){\n          groupIndex = k0 ? groupIndex : [];\n        }\n        else{\n          groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);\n        }\n\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain…\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            g0 = oldGroups[++i0];\n            if (g0) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n\n          while (x1 <= x) {\n            j = newIndex[i1] + (iterable ? n0old : n0)\n\n\n            if(iterable){\n              if(groupIndex[j]){\n                groupIndex[j].push(k)\n              }\n              else{\n                groupIndex[j] = [k]\n              }\n            }\n            else{\n              groupIndex[j] = k;\n            }\n\n            // Always add new values to groups. Only remove when not in filter.\n            // This gives groups full information on data life-cycle.\n            g.value = add(g.value, data[j], true);\n            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater th1an all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n\n        // Fill in gaps with empty arrays where there may have been rows with empty iterables\n        if(iterable){\n          for (var index1 = 0; index1 < n; index1++) {\n            if(!groupIndex[index1]){\n              groupIndex[index1] = [];\n            }\n          }\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if(k > i0){\n          if(iterable){\n            for (i0 = 0; i0 < n0old; ++i0) {\n              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n              }\n            }\n          }\n          else{\n            for (i0 = 0; i0 < n0; ++i0) {\n              groupIndex[i0] = reIndex[groupIndex[i0]];\n            }\n          }\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1 || iterable) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = cr_null;\n            reset = cr_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if(iterable){\n            k++\n            return\n          }\n          if (++k === groupCapacity) {\n            reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n            groupCapacity = capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData(reIndex) {\n        if (k > 1 || iterable) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = cr_index(oldK, oldK),\n              i,\n              i0,\n              j;\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          if (!iterable) {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            }\n          } else {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                groupIndex[j] = groupIndex[i];\n                for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                  seenGroups[groupIndex[j][i0]] = 1;\n                }\n                ++j;\n              }\n            }\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1 || iterable) {\n            // Reindex the group index using seenGroups to find the new index.\n            if (!iterable) {\n              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n            } else {\n              for (i = 0; i < j; ++i) {\n                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                }\n              }\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = cr_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = cr_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            j,\n            k,\n            n,\n            g;\n\n        if(iterable){\n          // Add the added values.\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceAdd(g.value, data[k], false, j);\n              }\n            }\n          }\n\n          // Remove the removed values.\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceRemove(g.value, data[k], notFilter, j);\n              }\n            }\n          }\n          return;\n        }\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            j,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        if(iterable){\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < groupIndex[i].length; j++) {\n              g = groups[groupIndex[i][j]];\n              g.value = reduceAdd(g.value, data[i], true, j);\n            }\n          }\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceRemove(g.value, data[i], false, j);\n              }\n            }\n          }\n          return;\n        }\n\n        for (i = 0; i < n; ++i) {\n          g = groups[groupIndex[i]];\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        for (i = 0; i < n; ++i) {\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = xfilterHeapselect.by(valueOf);\n        heap = xfilterHeap.by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(cr_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        i = dimensionGroups.indexOf(group);\n        if (i >= 0) dimensionGroups.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(cr_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      filters.masks[offset] &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Cycle through all the values.\n      for (i = n0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, filterOffset, added, removed, notFilter) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (filters.zero(k = added[i])) {\n          reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters.only(k = removed[i], filterOffset, filterOne)) {\n          reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      // Cycle through all the values.\n      for (i = 0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if it is filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i, 1);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i, 1);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  // Returns the raw row data contained in this crossfilter\n  function all(){\n    return data;\n  }\n\n  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n  function allFiltered(ignore_dimensions) {\n    var array = [],\n        i = 0,\n        mask = maskForDimensions(ignore_dimensions || []);\n\n      for (i = 0; i < n; i++) {\n        if (filters.zeroExceptMask(i, mask)) {\n          array.push(data[i]);\n        }\n      }\n\n      return array;\n  }\n\n  function onChange(cb){\n    if(typeof cb !== 'function'){\n      /* eslint no-console: 0 */\n      console.warn('onChange callback parameter must be a function!');\n      return;\n    }\n    callbacks.push(cb);\n    return function(){\n      callbacks.splice(callbacks.indexOf(cb), 1);\n    };\n  }\n\n  function triggerOnChange(eventName){\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](eventName);\n    }\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction cr_index(n, m) {\n  return (m < 0x101\n      ? xfilterArray.array8 : m < 0x10001\n      ? xfilterArray.array16\n      : xfilterArray.array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction cr_range(n) {\n  var range = cr_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n","import crossfilter from 'crossfilter2';\n\nvar value_count = {\n\tadd: function (a, prior, path) {\n\t\tvar i, curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\t// Not sure if this is more efficient than sorting.\n\t\t\ti = path(p).bisect(path(p).values, a(v), 0, path(p).values.length);\n\t\t\tcurr = path(p).values[i];\n\t\t\tif(curr && curr[0] === a(v)) {\n\t\t\t\t// Value already exists in the array - increment it\n\t\t\t\tcurr[1]++;\n\t\t\t} else {\n\t\t\t\t// Value doesn't exist - add it in form [value, 1]\n\t\t\t\tpath(p).values.splice(i, 0, [a(v), 1]);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\tvar i;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\ti = path(p).bisect(path(p).values, a(v), 0, path(p).values.length);\n\t\t\t// Value already exists or something has gone terribly wrong.\n\t\t\tpath(p).values[i][1]--;\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\t// Array[Array[value, count]]\n\t\t\tpath(p).values = [];\n\t\t\tpath(p).bisect = crossfilter.bisect.by(function(d) { return d[0]; }).left;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default value_count;","import crossfilter from 'crossfilter2';\n\nvar value_list = {\n\tadd: function (a, prior, path) {\n\t\tvar i;\n\t\tvar bisect = crossfilter.bisect.by(function(d) { return d; }).left;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\t// Not sure if this is more efficient than sorting.\n\t\t\ti = bisect(path(p).valueList, a(v), 0, path(p).valueList.length);\n\t\t\tpath(p).valueList.splice(i, 0, a(v));\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\tvar i;\n\t\tvar bisect = crossfilter.bisect.by(function(d) { return d; }).left;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\ti = bisect(path(p).valueList, a(v), 0, path(p).valueList.length);\n\t\t\t// Value already exists or something has gone terribly wrong.\n\t\t\tpath(p).valueList.splice(i, 1);\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).valueList = [];\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default value_list;","var exception_count = {\n\tadd: function (a, prior, path) {\n\t\tvar i, curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\t// Only count++ if the p.values array doesn't contain a(v) or if it's 0.\n\t\t\ti = path(p).bisect(path(p).values, a(v), 0, path(p).values.length);\n\t\t\tcurr = path(p).values[i];\n\t\t\tif((!curr || curr[0] !== a(v)) || curr[1] === 0) {\n\t\t\t\tpath(p).exceptionCount++;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\tvar i, curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\t// Only count-- if the p.values array contains a(v) value of 1.\n\t\t\ti = path(p).bisect(path(p).values, a(v), 0, path(p).values.length);\n\t\t\tcurr = path(p).values[i];\n\t\t\tif(curr && curr[0] === a(v) && curr[1] === 1) {\n\t\t\t\tpath(p).exceptionCount--;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).exceptionCount = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default exception_count;","var exception_sum = {\n\tadd: function (a, sum, prior, path) {\n\t\tvar i, curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\t// Only sum if the p.values array doesn't contain a(v) or if it's 0.\n\t\t\ti = path(p).bisect(path(p).values, a(v), 0, path(p).values.length);\n\t\t\tcurr = path(p).values[i];\n\t\t\tif((!curr || curr[0] !== a(v)) || curr[1] === 0) {\n\t\t\t\tpath(p).exceptionSum = path(p).exceptionSum + sum(v);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, sum, prior, path) {\n\t\tvar i, curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\t// Only sum if the p.values array contains a(v) value of 1.\n\t\t\ti = path(p).bisect(path(p).values, a(v), 0, path(p).values.length);\n\t\t\tcurr = path(p).values[i];\n\t\t\tif(curr && curr[0] === a(v) && curr[1] === 1) {\n\t\t\t\tpath(p).exceptionSum = path(p).exceptionSum - sum(v);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).exceptionSum = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default exception_sum;","import crossfilter from 'crossfilter2';\n\nvar histogram = {\n\tadd: function (a, prior, path) {\n\t\tvar bisect = crossfilter.bisect.by(function(d) { return d; }).left;\n\t\tvar bisectHisto = crossfilter.bisect.by(function(d) { return d.x; }).right;\n\t\tvar curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tcurr = path(p).histogram[bisectHisto(path(p).histogram, a(v), 0, path(p).histogram.length) - 1];\n\t\t\tcurr.y++;\n\t\t\tcurr.splice(bisect(curr, a(v), 0, curr.length), 0, a(v));\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\tvar bisect = crossfilter.bisect.by(function(d) { return d; }).left;\n\t\tvar bisectHisto = crossfilter.bisect.by(function(d) { return d.x; }).right;\n\t\tvar curr;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tcurr = path(p).histogram[bisectHisto(path(p).histogram, a(v), 0, path(p).histogram.length) - 1];\n\t\t\tcurr.y--;\n\t\t\tcurr.splice(bisect(curr, a(v), 0, curr.length), 1);\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (thresholds, prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).histogram = [];\n\t\t\tvar arr = [];\n\t\t\tfor(var i = 1; i < thresholds.length; i++) {\n\t\t\t\tarr = [];\n\t\t\t\tarr.x = thresholds[i - 1];\n\t\t\t\tarr.dx = (thresholds[i] - thresholds[i - 1]);\n\t\t\t\tarr.y = 0;\n\t\t\t\tpath(p).histogram.push(arr);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default histogram;","var sum_of_sq = {\n\tadd: function (a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p).sumOfSq = path(p).sumOfSq + a(v)*a(v);\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p).sumOfSq = path(p).sumOfSq - a(v)*a(v);\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).sumOfSq = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default sum_of_sq;","var std = {\n\tadd: function (prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tif(path(p).count > 0) {\n\t\t\t\tpath(p).std = 0.0;\n\t\t\t\tvar n = path(p).sumOfSq - path(p).sum*path(p).sum/path(p).count;\n\t\t\t\tif (n>0.0) path(p).std = Math.sqrt(n/(path(p).count-1));\n\t\t\t} else {\n\t\t\t\tpath(p).std = 0.0;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tif(path(p).count > 0) {\n\t\t\t\tpath(p).std = 0.0;\n\t\t\t\tvar n = path(p).sumOfSq - path(p).sum*path(p).sum/path(p).count;\n\t\t\t\tif (n>0.0) path(p).std = Math.sqrt(n/(path(p).count-1));\n\t\t\t} else {\n\t\t\t\tpath(p).std = 0;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).std = 0;\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default std;","import crossfilter from 'crossfilter2';\n\nvar nest = {\n\tadd: function (keyAccessors, prior, path) {\n\t\tvar i; // Current key accessor\n\t\tvar arrRef;\n\t\tvar newRef;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\n\t\t\tarrRef = path(p).nest;\n\t\t\tkeyAccessors.forEach(function(a) {\n\t\t\t\tnewRef = arrRef.filter(function(d) { return d.key === a(v); })[0];\n\t\t\t\tif(newRef) {\n\t\t\t\t\t// There is another level.\n\t\t\t\t\tarrRef = newRef.values;\n\t\t\t\t} else {\n\t\t\t\t\t// Next level doesn't yet exist so we create it.\n\t\t\t\t\tnewRef = [];\n\t\t\t\t\tarrRef.push({ key: a(v), values: newRef });\n\t\t\t\t\tarrRef = newRef;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tarrRef.push(v);\n\t\t\t\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function (keyAccessors, prior, path) {\n\t\tvar arrRef;\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\n\t\t\tarrRef = path(p).nest;\n\t\t\tkeyAccessors.forEach(function(a) {\n\t\t\t\tarrRef = arrRef.filter(function(d) { return d.key === a(v); })[0].values;\n\t\t\t});\n\n\t\t\t// Array contains an actual reference to the row, so just splice it out.\n\t\t\tarrRef.splice(arrRef.indexOf(v), 1);\n\n\t\t\t// If the leaf now has length 0 and it's not the base array remove it.\n\t\t\t// TODO\n\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function (prior, path) {\n\t\treturn function (p) {\n\t\t\tp = prior(p);\n\t\t\tpath(p).nest = [];\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default nest;","var alias = {\n\tinitial: function(prior, path, obj) {\n\t\treturn function (p) {\n\t\t\tif(prior) p = prior(p);\n\t\t\tfunction buildAliasFunction(key){\n\t\t\t\treturn function(){\n\t\t\t\t\treturn obj[key](path(p));\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor(var prop in obj) {\n\t\t\t\tpath(p)[prop] = buildAliasFunction(prop);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default alias;","var alias_prop = {\n\tadd: function (obj, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tfor(var prop in obj) {\n\t\t\t\tpath(p)[prop] = obj[prop](path(p),v);\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default alias_prop;","var data_list = {\n\tadd: function(a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p).dataList.push(v);\n\t\t\treturn p;\n\t\t};\n\t},\n\tremove: function(a, prior, path) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\tpath(p).dataList.splice(path(p).dataList.indexOf(v), 1);\n\t\t\treturn p;\n\t\t};\n\t},\n\tinitial: function(prior, path) {\n\t\treturn function (p) {\n\t\t\tif(prior) p = prior(p);\n\t\t\tpath(p).dataList = [];\n\t\t\treturn p;\n\t\t};\n\t}\n};\n\nexport default data_list;\n","var custom = {\n\tadd: function(prior, path, addFn) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\treturn addFn(p, v);\n\t\t};\n\t},\n\tremove: function(prior, path, removeFn) {\n\t\treturn function (p, v, nf) {\n\t\t\tif(prior) prior(p, v, nf);\n\t\t\treturn removeFn(p, v);\n\t\t};\n\t},\n\tinitial: function(prior, path, initialFn) {\n\t\treturn function (p) {\t\n\t\t\tif(prior) p = prior(p);\n\t\t\treturn initialFn(p);\n\t\t};\n\t}\n};\n\nexport default custom;","import filter from './filter.js';\nimport count from './count.js';\nimport sum from './sum.js';\nimport avg from './avg.js';\nimport median from './median.js';\nimport min from './min.js';\nimport max from './max.js';\nimport value_count from './value-count.js';\nimport value_list from './value-list.js';\nimport exception_count from './exception-count.js';\nimport exception_sum from './exception-sum.js';\nimport histogram from './histogram.js';\nimport sum_of_sq from './sum-of-squares.js';\nimport std from './std.js';\nimport nest from './nest.js';\nimport alias from './alias.js';\nimport alias_prop from './aliasProp.js';\nimport data_list from './data-list.js';\nimport custom from './custom.js';\n\nfunction build_function(p, f, path) {\n\t// We have to build these functions in order. Eventually we can include dependency\n\t// information and create a dependency graph if the process becomes complex enough.\n\n\tif(!path) path = function (d) { return d; };\n\n\t// Keep track of the original reducers so that filtering can skip back to\n\t// them if this particular value is filtered out.\n\tvar origF = {\n\t\treduceAdd: f.reduceAdd,\n\t\treduceRemove: f.reduceRemove,\n\t\treduceInitial: f.reduceInitial\n\t};\n\n\tif(p.count || p.std) {\n    f.reduceAdd = count.add(f.reduceAdd, path, p.count);\n    f.reduceRemove = count.remove(f.reduceRemove, path, p.count);\n    f.reduceInitial = count.initial(f.reduceInitial, path, p.count);\n\t}\n\n\tif(p.sum) {\n\t\tf.reduceAdd = sum.add(p.sum, f.reduceAdd, path);\n\t\tf.reduceRemove = sum.remove(p.sum, f.reduceRemove, path);\n\t\tf.reduceInitial = sum.initial(f.reduceInitial, path);\n\t}\n\n\tif(p.avg) {\n\t\tif(!p.count || !p.sum) {\n\t\t\tconsole.error(\"You must set .count(true) and define a .sum(accessor) to use .avg(true).\");\n\t\t} else {\n\t\t\tf.reduceAdd = avg.add(p.sum, f.reduceAdd, path);\n\t\t\tf.reduceRemove = avg.remove(p.sum, f.reduceRemove, path);\n\t\t\tf.reduceInitial = avg.initial(f.reduceInitial, path);\n\t\t}\n\t}\n\n\t// The unique-only reducers come before the value_count reducers. They need to check if\n\t// the value is already in the values array on the group. They should only increment/decrement\n\t// counts if the value not in the array or the count on the value is 0.\n\tif(p.exceptionCount) {\n\t\tif(!p.exceptionAccessor) {\n\t\t\tconsole.error(\"You must define an .exception(accessor) to use .exceptionCount(true).\");\n\t\t} else {\n\t\t\tf.reduceAdd = exception_count.add(p.exceptionAccessor, f.reduceAdd, path);\n\t\t\tf.reduceRemove = exception_count.remove(p.exceptionAccessor, f.reduceRemove, path);\n\t\t\tf.reduceInitial = exception_count.initial(f.reduceInitial, path);\n\t\t}\n\t}\n\n\tif(p.exceptionSum) {\n\t\tif(!p.exceptionAccessor) {\n\t\t\tconsole.error(\"You must define an .exception(accessor) to use .exceptionSum(accessor).\");\n\t\t} else {\n\t\t\tf.reduceAdd = exception_sum.add(p.exceptionAccessor, p.exceptionSum, f.reduceAdd, path);\n\t\t\tf.reduceRemove = exception_sum.remove(p.exceptionAccessor, p.exceptionSum, f.reduceRemove, path);\n\t\t\tf.reduceInitial = exception_sum.initial(f.reduceInitial, path);\n\t\t}\n\t}\n\n\t// Maintain the values array.\n\tif(p.valueList || p.median || p.min || p.max) {\n\t\tf.reduceAdd = value_list.add(p.valueList, f.reduceAdd, path);\n\t\tf.reduceRemove = value_list.remove(p.valueList, f.reduceRemove, path);\n\t\tf.reduceInitial = value_list.initial(f.reduceInitial, path);\n\t}\n\n\t// Maintain the data array.\n\tif(p.dataList) {\n\t\tf.reduceAdd = data_list.add(p.dataList, f.reduceAdd, path);\n\t\tf.reduceRemove = data_list.remove(p.dataList, f.reduceRemove, path);\n\t\tf.reduceInitial = data_list.initial(f.reduceInitial, path);\n\t}\n\n\tif(p.median) {\n\t\tf.reduceAdd = median.add(f.reduceAdd, path);\n\t\tf.reduceRemove = median.remove(f.reduceRemove, path);\n\t\tf.reduceInitial = median.initial(f.reduceInitial, path);\n\t}\n\n\tif(p.min) {\n\t\tf.reduceAdd = min.add(f.reduceAdd, path);\n\t\tf.reduceRemove = min.remove(f.reduceRemove, path);\n\t\tf.reduceInitial = min.initial(f.reduceInitial, path);\n\t}\n\n\tif(p.max) {\n\t\tf.reduceAdd = max.add(f.reduceAdd, path);\n\t\tf.reduceRemove = max.remove(f.reduceRemove, path);\n\t\tf.reduceInitial = max.initial(f.reduceInitial, path);\n\t}\n\n\t// Maintain the values count array.\n\tif(p.exceptionAccessor) {\n\t\tf.reduceAdd = value_count.add(p.exceptionAccessor, f.reduceAdd, path);\n\t\tf.reduceRemove = value_count.remove(p.exceptionAccessor, f.reduceRemove, path);\n\t\tf.reduceInitial = value_count.initial(f.reduceInitial, path);\n\t}\n\n\t// Histogram\n\tif(p.histogramValue && p.histogramThresholds) {\n\t\tf.reduceAdd = histogram.add(p.histogramValue, f.reduceAdd, path);\n\t\tf.reduceRemove = histogram.remove(p.histogramValue, f.reduceRemove, path);\n\t\tf.reduceInitial = histogram.initial(p.histogramThresholds ,f.reduceInitial, path);\n\t}\n\n\t// Sum of Squares\n\tif(p.sumOfSquares) {\n\t\tf.reduceAdd = sum_of_sq.add(p.sumOfSquares, f.reduceAdd, path);\n\t\tf.reduceRemove = sum_of_sq.remove(p.sumOfSquares, f.reduceRemove, path);\n\t\tf.reduceInitial = sum_of_sq.initial(f.reduceInitial, path);\n\t}\n\n\t// Standard deviation\n\tif(p.std) {\n\t\tif(!p.sumOfSquares || !p.sum) {\n\t\t\tconsole.error(\"You must set .sumOfSq(accessor) and define a .sum(accessor) to use .std(true). Or use .std(accessor).\");\n\t\t} else {\n\t\t\tf.reduceAdd = std.add(f.reduceAdd, path);\n\t\t\tf.reduceRemove = std.remove(f.reduceRemove, path);\n\t\t\tf.reduceInitial = std.initial(f.reduceInitial, path);\n\t\t}\n\t}\n\n\t// Custom reducer defined by 3 functions : add, remove, initial\n\tif (p.custom) {\n\t\tf.reduceAdd = custom.add(f.reduceAdd, path, p.custom.add);\n\t\tf.reduceRemove = custom.remove(f.reduceRemove, path, p.custom.remove);\n\t\tf.reduceInitial = custom.initial(f.reduceInitial, path, p.custom.initial);\n\t}\n\n\t// Nesting\n\tif(p.nestKeys) {\n\t\tf.reduceAdd = nest.add(p.nestKeys, f.reduceAdd, path);\n\t\tf.reduceRemove = nest.remove(p.nestKeys, f.reduceRemove, path);\n\t\tf.reduceInitial = nest.initial(f.reduceInitial, path);\n\t}\n\n\t// Alias functions\n\tif(p.aliasKeys) {\n\t\tf.reduceInitial = alias.initial(f.reduceInitial, path, p.aliasKeys);\n\t}\n\n\t// Alias properties - this is less efficient than alias functions\n\tif(p.aliasPropKeys) {\n\t\tf.reduceAdd = alias_prop.add(p.aliasPropKeys, f.reduceAdd, path);\n\t\t// This isn't a typo. The function is the same for add/remove.\n\t\tf.reduceRemove = alias_prop.add(p.aliasPropKeys, f.reduceRemove, path);\n\t}\n\n\t// Filters determine if our built-up priors should run, or if it should skip\n\t// back to the filters given at the beginning of this build function.\n\tif (p.filter) {\n\t\tf.reduceAdd = filter.add(p.filter, f.reduceAdd, origF.reduceAdd, path);\n\t\tf.reduceRemove = filter.remove(p.filter, f.reduceRemove, origF.reduceRemove, path);\n\t}\n\n\t// Values go last.\n\tif(p.values) {\n\t\tObject.getOwnPropertyNames(p.values).forEach(function(n) {\n\t\t\t// Set up the path on each group.\n\t\t\tvar setupPath = function(prior) {\n\t\t\t\treturn function (p) {\n\t\t\t\t\tp = prior(p);\n\t\t\t\t\tpath(p)[n] = {};\n\t\t\t\t\treturn p;\n\t\t\t\t};\n\t\t\t};\n\t\t\tf.reduceInitial = setupPath(f.reduceInitial);\n\t\t\tbuild_function(p.values[n].parameters, f, function (p) { return p[n]; });\n\t\t});\n\t}\n}\n\nvar build = {\n\tbuild: build_function\n};\n\nexport default build;\n","import parameters from './parameters.js';\n\nfunction assign(target) {\n\tif (target == null) {\n\t\tthrow new TypeError('Cannot convert undefined or null to object');\n\t}\n\n\tvar output = Object(target);\n\tfor (var index = 1; index < arguments.length; ++index) {\n\t\tvar source = arguments[index];\n\t\tif (source != null) {\n\t\t\tfor (var nextKey in source) {\n\t\t\t\tif(source.hasOwnProperty(nextKey)) {\n\t\t\t\t\toutput[nextKey] = source[nextKey];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn output;\n}\n\nfunction accessor_build(obj, p) {\n\t// obj.order = function(value) {\n\t// \tif (!arguments.length) return p.order;\n\t// \tp.order = value;\n\t// \treturn obj;\n\t// };\n\n\t// Converts a string to an accessor function\n\tfunction accessorify(v) {\n\t\tif( typeof v === 'string' ) {\n\t\t\t// Rewrite to a function\n\t\t\tvar tempValue = v;\n\t\t\tvar func = function (d) { return d[tempValue]; }\n\t\t\treturn func;\n\t\t} else {\n\t\t\treturn v;\n\t\t}\n\t}\n\n\t// Converts a string to an accessor function\n\tfunction accessorifyNumeric(v) {\n\t\tif( typeof v === 'string' ) {\n\t\t\t// Rewrite to a function\n\t\t\tvar tempValue = v;\n\t\t\tvar func = function (d) { return +d[tempValue]; }\n\t\t\treturn func;\n\t\t} else {\n\t\t\treturn v;\n\t\t}\n\t}\n\n\tobj.fromObject = function(value) {\n\t\tif(!arguments.length) return p;\n\t\tassign(p, value);\n\t\treturn obj;\n\t};\n\n\tobj.toObject = function() {\n\t\treturn p;\n\t};\n\n\tobj.count = function(value, propName) {\n\t\tif (!arguments.length) return p.count;\n    if (!propName) {\n      propName = 'count';\n    }\n\t\tp.count = propName;\n\t\treturn obj;\n\t};\n\n\tobj.sum = function(value) {\n\t\tif (!arguments.length) return p.sum;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tp.sum = value;\n\t\treturn obj;\n\t};\n\n\tobj.avg = function(value) {\n\t\tif (!arguments.length) return p.avg;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\t// We can take an accessor function, a boolean, or a string\n\t\tif( typeof value === 'function' ) {\n\t\t\tif(p.sum && p.sum !== value) console.warn('SUM aggregation is being overwritten by AVG aggregation');\n\t\t\tp.sum = value;\n\t\t\tp.avg = true;\n\t\t\tp.count = 'count';\n\t\t} else {\n\t\t\tp.avg = value;\n\t\t}\n\t\treturn obj;\n\t};\n\n\tobj.exception = function(value) {\n\t\tif (!arguments.length) return p.exceptionAccessor;\n\n\t\tvalue = accessorify(value);\n\n\t\tp.exceptionAccessor = value;\n\t\treturn obj;\n\t};\n\n\tobj.filter = function(value) {\n\t\tif (!arguments.length) return p.filter;\n\t\tp.filter = value;\n\t\treturn obj;\n\t};\n\n\tobj.valueList = function(value) {\n\t\tif (!arguments.length) return p.valueList;\n\n\t\tvalue = accessorify(value);\n\n\t\tp.valueList = value;\n\t\treturn obj;\n\t};\n\n\tobj.median = function(value) {\n\t\tif (!arguments.length) return p.median;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tif(typeof value === 'function') {\n\t\t\tif(p.valueList && p.valueList !== value) console.warn('VALUELIST accessor is being overwritten by median aggregation');\n\t\t\tp.valueList = value;\n\t\t}\n\t\tp.median = value;\n\t\treturn obj;\n\t};\n\n\tobj.min = function(value) {\n\t\tif (!arguments.length) return p.min;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tif(typeof value === 'function') {\n\t\t\tif(p.valueList && p.valueList !== value) console.warn('VALUELIST accessor is being overwritten by min aggregation');\n\t\t\tp.valueList = value;\n\t\t}\n\t\tp.min = value;\n\t\treturn obj;\n\t};\n\n\tobj.max = function(value) {\n\t\tif (!arguments.length) return p.max;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tif(typeof value === 'function') {\n\t\t\tif(p.valueList && p.valueList !== value) console.warn('VALUELIST accessor is being overwritten by max aggregation');\n\t\t\tp.valueList = value;\n\t\t}\n\t\tp.max = value;\n\t\treturn obj;\n\t};\n\n\tobj.exceptionCount = function(value) {\n\t\tif (!arguments.length) return p.exceptionCount;\n\n\t\tvalue = accessorify(value);\n\n\t\tif( typeof value === 'function' ) {\n\t\t\tif(p.exceptionAccessor && p.exceptionAccessor !== value) console.warn('EXCEPTION accessor is being overwritten by exception count aggregation');\n\t\t\tp.exceptionAccessor = value;\n\t\t\tp.exceptionCount = true;\n\t\t} else {\n\t\t\tp.exceptionCount = value;\n\t\t}\n\t\treturn obj;\n\t};\n\n\tobj.exceptionSum = function(value) {\n\t\tif (!arguments.length) return p.exceptionSum;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tp.exceptionSum = value;\n\t\treturn obj;\n\t};\n\n\tobj.histogramValue = function(value) {\n\t\tif (!arguments.length) return p.histogramValue;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tp.histogramValue = value;\n\t\treturn obj;\n\t};\n\n\tobj.histogramBins = function(value) {\n\t\tif (!arguments.length) return p.histogramThresholds;\n\t\tp.histogramThresholds = value;\n\t\treturn obj;\n\t};\n\n\tobj.std = function(value) {\n\t\tif (!arguments.length) return p.std;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tif(typeof(value) === 'function') {\n\t\t\tp.sumOfSquares = value;\n\t\t\tp.sum = value;\n\t\t\tp.count = 'count';\n\t\t\tp.std = true;\n\t\t} else {\n\t\t\tp.std = value;\n\t\t}\n\t\treturn obj;\n\t};\n\n\tobj.sumOfSq = function(value) {\n\t\tif (!arguments.length) return p.sumOfSquares;\n\n\t\tvalue = accessorifyNumeric(value);\n\n\t\tp.sumOfSquares = value;\n\t\treturn obj;\n\t};\n\n\tobj.value = function(value, accessor) {\n\t\tif (!arguments.length || typeof value !== 'string' ) {\n\t\t\tconsole.error(\"'value' requires a string argument.\");\n\t\t} else {\n\t\t\tif(!p.values) p.values = {};\n\t\t\tp.values[value] = {};\n\t\t\tp.values[value].parameters = parameters();\n\t\t\taccessor_build(p.values[value], p.values[value].parameters);\n\t\t\tif(accessor) p.values[value].accessor = accessor;\n\t\t\treturn p.values[value];\n\t\t}\n\t};\n\n\tobj.nest = function(keyAccessorArray) {\n\t\tif(!arguments.length) return p.nestKeys;\n\n\t\tkeyAccessorArray.map(accessorify);\n\n\t\tp.nestKeys = keyAccessorArray;\n\t\treturn obj;\n\t};\n\n\tobj.alias = function(propAccessorObj) {\n\t\tif(!arguments.length) return p.aliasKeys;\n\t\tp.aliasKeys = propAccessorObj;\n\t\treturn obj;\n\t};\n\n\tobj.aliasProp = function(propAccessorObj) {\n\t\tif(!arguments.length) return p.aliasPropKeys;\n\t\tp.aliasPropKeys = propAccessorObj;\n\t\treturn obj;\n\t};\n\n\tobj.groupAll = function(groupTest) {\n\t\tif(!arguments.length) return p.groupAll;\n\t\tp.groupAll = groupTest;\n\t\treturn obj;\n\t};\n\n\tobj.dataList = function(value) {\n\t\tif (!arguments.length) return p.dataList;\n\t\tp.dataList = value;\n\t\treturn obj;\n\t};\n\n\tobj.custom = function(addRemoveInitialObj) {\n\t\tif (!arguments.length) return p.custom;\n\t\tp.custom = addRemoveInitialObj;\n\t\treturn obj;\n\t};\n\n}\n\nvar accessors = {\n\tbuild: accessor_build\n};\n\nexport default accessors;\n","var parameters = function() {\n\treturn {\n\t\torder: false,\n\t\tavg: false,\n\t\tcount: false,\n\t\tsum: false,\n\t\texceptionAccessor: false,\n\t\texceptionCount: false,\n\t\texceptionSum: false,\n\t\tfilter: false,\n\t\tvalueList: false,\n\t\tmedian: false,\n\t\thistogramValue: false,\n\t\tmin: false,\n\t\tmax: false,\n\t\thistogramThresholds: false,\n\t\tstd: false,\n\t\tsumOfSquares: false,\n\t\tvalues: false,\n\t\tnestKeys: false,\n\t\taliasKeys: false,\n\t\taliasPropKeys: false,\n\t\tgroupAll: false,\n\t\tdataList: false,\n\t\tcustom: false\n\t};\n};\n\nexport default parameters;\n","var pluck = function(n){\n    return function(d){\n        return d[n];\n    };\n};\n\n// supported operators are sum, avg, and count\nconst _grouper = function(path, prior){\n    if(!path) path = function(d){return d;};\n    return function(p, v){\n        if(prior) prior(p, v);\n        var x = path(p), y = path(v);\n        if(typeof y.count !== 'undefined') x.count += y.count;\n        if(typeof y.sum !== 'undefined') x.sum += y.sum;\n        if(typeof y.avg !== 'undefined') x.avg = x.sum/x.count;\n        return p;\n    };\n};\n\nconst cap = function (prior, f, p) {\n    var obj = f.reduceInitial();\n    // we want to support values so we'll need to know what those are\n    var values = p.values ? Object.keys(p.values) : [];\n    var _othersGrouper = _grouper();\n    if (values.length) {\n        for (var i = 0; i < values.length; ++i) {\n            _othersGrouper = _grouper(pluck(values[i]), _othersGrouper);\n        }\n    }\n    return function (cap, othersName) {\n        if (!arguments.length) return prior();\n        if( cap === Infinity || !cap ) return prior();\n        var all = prior();\n        var slice_idx = cap-1;\n        if(all.length <= cap) return all;\n        var data = all.slice(0, slice_idx);\n        var others = {key: othersName || 'Others'};\n        others.value = f.reduceInitial();\n        for (var i = slice_idx; i < all.length; ++i) {\n            _othersGrouper(others.value, all[i].value);\n        }\n        data.push(others);\n        return data;\n    };\n};\n\nexport default cap;\n","var pluck_n = function (n) {\n    if (typeof n === 'function') {\n        return n;\n    }\n    if (~n.indexOf('.')) {\n        var split = n.split('.');\n        return function (d) {\n            return split.reduce(function (p, v) {\n                return p[v];\n            }, d);\n        };\n    }\n    return function (d) {\n        return d[n];\n    };\n};\n\nfunction ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nvar comparer = function (accessor, ordering) {\n    return function (a, b) {\n        return ordering(accessor(a), accessor(b));\n    };\n};\n\nexport default function (prior) {\n    return function (value, order) {\n        if (arguments.length === 1) {\n            order = ascending;\n        }\n        return prior().sort(comparer(pluck_n(value), order));\n    };\n}\n","import build from './build.js';\nimport accessors from './accessors.js';\nimport params from './parameters.js';\nimport postprocess from './postprocess';\nimport postprocessors from './postprocessors';\nimport crossfilter from 'crossfilter2';\n\nfunction reductio() {\n\tvar parameters = params();\n\n\tvar funcs = {};\n\n\tfunction my(group) {\n\t\t// Start fresh each time.\n\t\tfuncs = {\n\t\t\treduceAdd: function(p) { return p; },\n\t\t\treduceRemove: function(p) { return p; },\n\t\t\treduceInitial: function () { return {}; },\n\t\t};\n\n\t\tbuild.build(parameters, funcs);\n\n\t\t// If we're doing groupAll\n\t\tif(parameters.groupAll) {\n\t\t\tif(group.top) {\n\t\t\t\tconsole.warn(\"'groupAll' is defined but attempting to run on a standard dimension.group(). Must run on dimension.groupAll().\");\n\t\t\t} else {\n\t\t\t\tvar bisect = crossfilter.bisect.by(function(d) { return d.key; }).left;\n\t\t\t\tvar i, j;\n\t\t\t\tvar keys;\n        var keysLength;\n        var k; // Key\n\t\t\t\tgroup.reduce(\n\t\t\t\t\tfunction(p, v, nf) {\n\t\t\t\t\t\tkeys = parameters.groupAll(v);\n            keysLength = keys.length;\n            for(j=0;j<keysLength;j++) {\n              k = keys[j];\n              i = bisect(p, k, 0, p.length);\n\t\t\t\t\t\t\tif(!p[i] || p[i].key !== k) {\n\t\t\t\t\t\t\t\t// If the group doesn't yet exist, create it first.\n\t\t\t\t\t\t\t\tp.splice(i, 0, { key: k, value: funcs.reduceInitial() });\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Then pass the record and the group value to the reducers\n\t\t\t\t\t\t\tfuncs.reduceAdd(p[i].value, v, nf);\n            }\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t},\n\t\t\t\t\tfunction(p, v, nf) {\n\t\t\t\t\t\tkeys = parameters.groupAll(v);\n            keysLength = keys.length;\n            for(j=0;j<keysLength;j++) {\n              i = bisect(p, keys[j], 0, p.length);\n\t\t\t\t\t\t\t// The group should exist or we're in trouble!\n\t\t\t\t\t\t\t// Then pass the record and the group value to the reducers\n\t\t\t\t\t\t\tfuncs.reduceRemove(p[i].value, v, nf);\n            }\n\t\t\t\t\t\treturn p;\n\t\t\t\t\t},\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tif(!group.all) {\n\t\t\t\t\t// Add an 'all' method for compatibility with standard Crossfilter groups.\n\t\t\t\t\tgroup.all = function() { return this.value(); };\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgroup.reduce(funcs.reduceAdd, funcs.reduceRemove, funcs.reduceInitial);\n\t\t}\n\n\t\tpostprocessed(group, parameters, funcs);\n\n\t\treturn group;\n\t}\n\n\taccessors.build(my, parameters);\n\n\treturn my;\n}\n\npostprocessors(reductio);\nconst postprocessed = postprocess(reductio);\n\nexport default reductio;\n","import cap from './cap';\nimport sortBy from './sortBy';\n\nexport default function(reductio){\n    reductio.postprocessors = {};\n    reductio.registerPostProcessor = function(name, func){\n        reductio.postprocessors[name] = func;\n    };\n\n    reductio.registerPostProcessor('cap', cap);\n    reductio.registerPostProcessor('sortBy', sortBy);\n}\n","function postProcess(reductio) {\n    return function (group, p, f) {\n        group.post = function(){\n            var postprocess = function () {\n                return postprocess.all();\n            };\n            postprocess.all = function () {\n                return group.all();\n            };\n            var postprocessors = reductio.postprocessors;\n            Object.keys(postprocessors).forEach(function (name) {\n                postprocess[name] = function () {\n                    var _all = postprocess.all;\n                    var args = [].slice.call(arguments);\n                    postprocess.all = function () {\n                        return postprocessors[name](_all, f, p).apply(null, args);\n                    };\n                    return postprocess;\n                };\n            });\n            return postprocess;\n        };\n    };\n}\n\nexport default postProcess;\n"],"names":["filter","prior","skip","p","v","nf","count","path","propName","sum","a","avg","median","half","Math","floor","valueList","length","undefined","min","max","array8","arrayUntyped","array16","array32","arrayLengthen","arrayLengthenUntyped","arrayWiden","arrayWidenUntyped","n","array","Array","i","width","Error","bitarray","subarrays","masks","Uint8Array","Uint16Array","Uint32Array","copy","constructor","set","prototype","lengthen","len","this","add","m","w","one","offset","dest","src","truncate","j","zero","zeroExcept","zeroExceptMask","mask","only","onlyExcept","onlyOffset","onlyOne","bisect","value","values","left","right","range","d","heap_by","f","heap","lo","hi","sift","child","x","sort","t","h","identity","heapselect_by","xFilterHeap","by","k","queue","bisect_by","bisectRight","mid","index","deep","JSON","parse","stringify","get","obj","prop","call","reg","action","keys","id","key","split","splice","replace","crossfilter","filters","remove","removeData","dimension","groupAll","size","all","allFiltered","onChange","isElementFiltered","data","filterListeners","dataListeners","removeDataListeners","callbacks","newData","n0","n1","concat","forEach","l","triggerOnChange","predicate","newIndex","removed","usePred","index1","index2","push","index3","index4","maskForDimensions","dimensions","ignore_dimensions","iterable","accessorPath","result","newValues","iterablesIndexCount","iterablesIndexFilterStatus","refilterFunction","filterValue","filterValuePresent","filterAll","isArray","filterRange","filterFunction","filterExact","currentFilter","hasCurrentFilter","top","top_offset","hi0","toSkip","lo0","iterablesEmptyRows","bottom","bottom_offset","group","g","cr_null","order","orderNatural","dispose","accessor","sortRange","cr_range","A","B","b","refilter","xfilterFilter","indexListeners","dimensionGroups","unshift","preAdd","postAdd","tmp","newIterablesIndexCount","newIterablesIndexFilterStatus","i0","cr_index","unsortedIndex","sortMap","permute","map","bounds","lo1","hi1","old_n0","oldValues","oldIndex","oldIterablesIndexFilterStatus","i1","oldiiclength","xfilterArray","index5","reIndex","slice","oldDataIndex","filterIndexBounds","filterIndexFunction","added","valueIndexAdded","valueIndexRemoved","newAdded","newRemoved","indexLength","reduce","reduceCount","reduceSum","groups","groupIndex","select","reduceAdd","reduceRemove","reduceInitial","n0old","groupWidth","groupCapacity","capacity","update","reset","resetNeeded","g0","x0","x1","oldGroups","initial","k0","groupIncrement","indexOf","updateMany","resetMany","updateOne","resetOne","oldK","seenGroups","filterOne","filterOffset","notFilter","xfilterReduce","cr_zero","valueOf","xfilterHeapselect","xfilterHeap","cr_identity","arguments","log","reduceValue","cb","console","warn","eventName","heapselect","value_count","curr","value_list","exception_count","exceptionCount","exception_sum","exceptionSum","histogram","bisectHisto","y","thresholds","arr","dx","sum_of_sq","sumOfSq","std","sqrt","nest","keyAccessors","arrRef","newRef","alias","buildAliasFunction","alias_prop","data_list","dataList","custom","addFn","removeFn","initialFn","build","build_function","origF","error","exceptionAccessor","histogramValue","histogramThresholds","sumOfSquares","nestKeys","aliasKeys","aliasPropKeys","Object","getOwnPropertyNames","parameters","assign","target","TypeError","output","source","nextKey","hasOwnProperty","accessors","accessor_build","accessorify","tempValue","accessorifyNumeric","fromObject","toObject","exception","histogramBins","keyAccessorArray","propAccessorObj","aliasProp","groupTest","addRemoveInitialObj","pluck","_grouper","cap","_othersGrouper","othersName","Infinity","slice_idx","others","pluck_n","ascending","NaN","comparer","ordering","reductio","funcs","my","keysLength","postprocessed","postprocessors","registerPostProcessor","name","func","sortBy","post","postprocess","_all","args","apply"],"mappings":"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"}